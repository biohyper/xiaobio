<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[xiaobio]]></title>
  <link href="https://biohyper.github.io/xiaobio/atom.xml" rel="self"/>
  <link href="https://biohyper.github.io/xiaobio/"/>
  <updated>2019-04-10T15:50:20+08:00</updated>
  <id>https://biohyper.github.io/xiaobio/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>
  
  <entry>
    <title type="html"><![CDATA[Google Home]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640483.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640483.html</id>
    <content type="html">
<![CDATA[<h1 id="toc_0">Google 语令</h1>

<ul>
<li>turn on/off the power</li>
<li>turn on/off the lights</li>
<li>brighten/dim bedroom light</li>
<li>set the bedroom light to red/white</li>
<li>set the livingroom light to 50 percent</li>
<li>turn on/off the living room curtain</li>
<li>turn on/off the fragrance</li>
<li>turn on/off the humidity</li>
<li>turn on/off the air cleaner</li>
<li>turn on/off the air condition</li>
</ul>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Oracle常规操作及脚本]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640521.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640521.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">启动数据库</h2>

<pre class="line-numbers"><code class="language-text">su - oracle
sqlplus /nolog
conn /as sysdba
startup  
</code></pre>

<h2 id="toc_1">启动监听</h2>

<pre class="line-numbers"><code class="language-text">lsnrctl start
lsnrctl status
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_2">数据库配置助理，进行数据库安装、删除和修改</h2>

<p><code>$/oracle/oracle/app/product/101/bin/dbca</code></p>

<h2 id="toc_3">数据库网络服务配置管理</h2>

<p><code>$/oracle/oracle/app/product/101/bin/netca</code></p>

<h2 id="toc_4">数据库网络服务和监听配置助理</h2>

<p><code>$/oracle/oracle/app/product/101/bin/netmgr</code></p>

<h2 id="toc_5">关闭oracle</h2>

<pre class="line-numbers"><code class="language-text">su - oracle   
sqlplus /nolog   
conn /as sysdba   
shutdown immediate   
exit   
lsnrctl stop   
exit  
</code></pre>

<h2 id="toc_6">关闭一个insstance：</h2>

<p><code>srvctl stop instance  -d SID -i instance</code></p>

<h1 id="toc_7">部分记录</h1>

<p><code>alter table ningbo_rela_new modify (TERMINAL_BRAND varchar2(100))</code></p>

<pre class="line-numbers"><code class="language-text">create table ningbo_rela_new
(
  RI_QI varchar2(50),
  USER_MAC varchar2(50) ,
  USER_ACCOUNT varchar2(50),
  TERMINAL_TYPE varchar2(50),
  TERMINAL_BRAND varchar2(50),
  ON_TIME varchar2(50),
  LEAVE_TIME varchar2(50),
  APMAC varchar2(50),
  AP_NAME varchar2(500),
  WLAN_NAME varchar2(500),
  CITY_NAME varchar2(50),
  AREA_NAME varchar2(50),
  NASID varchar2(50)
)
</code></pre>

<p><code>alter table TABLE_NAME rename column FIELD_NAME to NEW_FIELD_NAME;</code></p>

<pre class="line-numbers"><code class="language-text">create table student (
studentid int primary key not null,
studentname varchar(8),
age int);
</code></pre>

<p><code>alter table test1<br/>
add (name varchar2(30) default ‘无名氏’ not null);</code></p>

<p><code>alter user da default tablespace da;</code></p>

<h2 id="toc_8">批量删除脚本</h2>

<p><code>sqlplus -S /nolog &lt;&lt;EOF<br/>
connect / as sysdba;<br/>
删除脚本<br/>
EOF</code></p>

<p>后台执行<code>nohup shell命令 &amp;</code></p>

<h2 id="toc_9">修改默认表空间</h2>

<p><code>alter user da default tablespace da</code></p>

<h2 id="toc_10">查看表信息</h2>

<p><code>desc table_name</code></p>

<h2 id="toc_11">查看连接用户session</h2>

<pre class="line-numbers"><code class="language-sql">SELECT b.spid, a.SID, b.osuser, a.machine, a.username, a.event,a.sql_text
  FROM (SELECT b.username, b.machine, a.event, a.SID, b.serial#, c.sql_text
          FROM v$session_wait a, v$session b, v$sql c
         WHERE a.SID = b.SID AND b.sql_id = c.sql_id) a,
       (SELECT spid, osuser, s.program, s.SID
          FROM v$session s, v$process p
         WHERE s.paddr = p.addr) b
 WHERE a.SID = b.SID
 ```
 
## 删除表空间
 
`DROP TABLESPACE da_temp INCLUDING CONTENTS AND DATAFILES;`

## 创建表空间

```sql
CREATE TEMPORARY TABLESPACE da_TEMP01 TEMPFILE 
  &#39;/data1/dadb/da_temp01.dbf&#39; SIZE 100M AUTOEXTEND ON NEXT 50M MAXSIZE 5G
TABLESPACE GROUP &#39;&#39;
EXTENT MANAGEMENT LOCAL UNIFORM SIZE 1M;
</code></pre>

<h2 id="toc_12">修改默认表空间</h2>

<p><code>ALTER DATABASE DEFAULT TEMPORARY TABLESPACE da_temp01</code></p>

<h2 id="toc_13">查看imei不为空或者不是0在所有imei中占的比例----日常数据库</h2>

<pre class="line-numbers"><code class="language-sql">select 
sum(case when ms_imei is null then 0 else 1 end) No_imei,
sum(case when ms_imei=0 then 0 when ms_imei is null then 0 else 1 end) No_add0_imei,
count(*) No_user,
sum(case when ms_imei is null then 0 else 1 end)/count(*)   No_rate,
sum(case when ms_imei=0 then 0 when ms_imei is null then 0 else 1 end)/count(*)  No_add0_rate

from gb t where imsi&gt;0
</code></pre>

<h2 id="toc_14">查看imei不为空或者不是0在所有imei中占的比例----应用数据库</h2>

<pre class="line-numbers"><code class="language-sql">select 
sum(case when imei is null then 0 else 1 end) &quot;2G_IMEI_No&quot;,
sum(case when imei_td is null then 0 else 1 end) &quot;3G_IMEI_td_No&quot;,
sum(case when imei is null then 0 when imei=0 then 0 else 1 end) &quot;2G_add0_IMEI_No&quot;,
sum(case when imei_td is null then 0 when imei_td=0 then 0 else 1 end) &quot;3G_add0_IMEI_td_No&quot;,
count(*) ALL_No,
sum(case when imei is null then 0 else 1 end)/count(*) &quot;2G_IMEI_RATE&quot;,
sum(case when imei_td is null then 0 else 1 end)/count(*)  &quot;3G_IMEI_td_RATE&quot;,
sum(case when imei is null then 0 when imei=0 then 0 else 1 end)/count(*) &quot;2G_add0_IMEI_Rate&quot;,
sum(case when imei_td is null then 0 when imei_td=0 then 0 else 1 end)/count(*) &quot;3G_add0_IMEI_td_Rate&quot;
from CFG_CUSTOMER
</code></pre>

<h2 id="toc_15">查看imei不为空在所有imei中占的比例----应用数据库库</h2>

<pre class="line-numbers"><code class="language-sql">select 
sum(case when imei is null then 0 else 1 end) &quot;2G_IMEI_No&quot;,
sum(case when imei_td is null then 0 else 1 end) &quot;3G_IMEI_td_No&quot;,
count(*) ALL_No,
sum(case when imei is null then 0 else 1 end)/count(*) &quot;2G_IMEI_RATE&quot;,
sum(case when imei_td is null then 0 else 1 end)/count(*)  &quot;3G_IMEI_td_RATE&quot;

from CFG_CUSTOMER
</code></pre>

<h1 id="toc_16">表空间相关操作</h1>

<h2 id="toc_17">mount状态offline表空间</h2>

<p><code>alter database datafile &#39;/data2/space1/DAT_DAILY_OTHER.1.DBF&#39; offline drop;</code></p>

<h2 id="toc_18">删除表空间</h2>

<p><code>drop tablespace DAT_DAILY_OTHER including CONTENTS and datafiles;</code></p>

<h2 id="toc_19">创建大文件表空间</h2>

<pre class="line-numbers"><code class="language-sql">CREATE BIGFILE TABLESPACE DAT_DAILY_OTHER DATAFILE 
  &#39;/data2/dailydb/DAT_DAILY_OTHER.1.DBF&#39; SIZE 5120M AUTOEXTEND ON NEXT 10240M MAXSIZE 34359738344K
NOLOGGING
DEFAULT 
COMPRESS BASIC 
ONLINE
EXTENT MANAGEMENT LOCAL UNIFORM SIZE 256K
BLOCKSIZE 8K
SEGMENT SPACE MANAGEMENT AUTO
FLASHBACK ON;
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下Oracle彻底删除实例]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640557.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640557.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">主要有两种方法，一般情况第一种方法可以实现</h2>

<h2 id="toc_1">方法一：用安装oracle的用户进行dbca</h2>

<p>图形界面执行<code>dbca</code>，从界面选择要删除的实例，按提示一步步执行即可，较简单！</p>

<h2 id="toc_2">方法二： dbca没有完全清除，需要其他操作来实现</h2>

<p>该方法数据库要处于<code>mount</code>状态，然后<code>alter system enable restricted session;</code></p>

<ul>
<li>执行步骤如下：</li>
</ul>

<pre class="line-numbers"><code class="language-sql">SQL&gt;shutdown abort;      ##关闭数据库
Database altered.
SQL&gt;startup mount;       #开启数据库到mount状态
SQL&gt; select status from v$instance;      #check数据库在mount状态
STATUS
------------
MOUNTED

SQL&gt; alter system enable restricted session;#
System altered.

SQL&gt; select status from v$instance;
STATUS
------------
MOUNTED

SQL&gt; drop database;
Database dropped.
</code></pre>

<span id="more"></span><!-- more -->

<p>此时alert.log记录信息：</p>

<pre class="line-numbers"><code class="language-text">Create Relation ADR_CONTROL
Create Relation ADR_INVALIDATION
Create Relation INC_METER_IMPT_DEF
Create Relation INC_METER_PK_IMPTS
USER (ospid: 8748): terminating the instance
Instance terminated by USER, pid = 8748
Deleted Oracle managed file /opt/app/ora11g/oradata/daily/controlfile/o1_mf_9x4fgq77_.ctl
Deleted Oracle managed file /opt/app/ora11g/flash_recovery_area/daily/controlfile/o1_mf_9x4fgypb_.ctl
Completed: drop database
Shutting down instance (abort)
License high water mark = 2
Fri Jul 25 19:09:26 2014
Instance shutdown complete
</code></pre>

<p>到<code>oradata</code>路径下看已经没有任何文件了，那么认为这个数据库已经被删除。<br/>
但再次执行dbca，创建相同实例的库时还会报错！因为虽然和daily实例关联的数据文件、日志文件等已经物理删除了，但和这实例相关的配置文件没有删除、<br/>
所以此时需要手工删除实例相关的配置：</p>

<ol>
<li>删除\(ORACLE_BASE/admin/\)ORACLE_SID所有目录。</li>
<li>删除$ORACLE_HOME/dbs下和SID相关的文件和参数文件，包括hc_daily.dat，init.ora，lkDAILY，orapwdaily。</li>
<li>删除/etc/oratab中和实例相关的部分。</li>
<li>可以在$ORACLE_HOME中执行find . -name daily，删除所有和实例相关的文件。</li>
</ol>

<p>删除结束后，再用安装oracle的用户进行<code>dbca</code>创建同名的数据库即可！</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle 11g 内存(sga和pga)参数设置]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640597.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640597.html</id>
    <content type="html">
<![CDATA[<p>安装Oracle 11g时没有修改SGA的话，需要在安装好以后调整<code>sga_target 1G,pga_aggregate_target 200M</code>(这2个参数在11g里面可能默认是0)，然后重启数据库</p>

<p>oracle占用系统总内存大小要根据实际业务量来确定，一般Oracle使用的大小为系统内存的<code>60%</code>或者<code>80%</code>，而SGA和PGA的比例一般为<code>6:4</code><br/>
即：<br/>
<code>SGA = system_total_memory * 60%(80%) * 60%</code><br/>
<code>PGA = system_total_memory * 60%(80%) * 40%</code><br/>
<figure><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1xdq9qbjaj31900u0wr2.jpg" alt=""/></figure></p>

<span id="more"></span><!-- more -->

<p>修改前切记备份spfile，<code>create pfile =&#39;/home/oracle/yourname.ora&#39; from spfile;</code></p>

<p>查看内存参数：<br/>
<code>show parameter memory</code></p>

<p>修改总内存最大值：<br/>
<code>alter system set memory_max_target =1024M scope=spfile;</code></p>

<p>修改总内存大小：<br/>
<code>alter system set memory_target = 512M scope=spfile;</code></p>

<p>修改sga大小：<br/>
<code>alter systemset sga_max_size=1024m scope=spfile;</code></p>

<p>修改pga大小：<br/>
<code>alter system set pga_aggregate_target=500M scope=spfile;</code></p>

<blockquote>
<p>所有修改重启数据库后生效</p>
</blockquote>

<h2 id="toc_0">可能出现报错：</h2>

<p><code>ORA-00844: Parameter not taking MEMORY_TARGET into account, see alert log for more information</code><br/>
由于设置了Oracle的MEMORY_TARGET参数的值小于了SGA_TARGET和PGA_TARGET的总和，所以报错。</p>

<blockquote>
<p><code>MEMORY_TARGET</code>就是<code>sga_target + pga_aggregate_target</code></p>
</blockquote>

<p>这个时候数据库已经无法启动，也就无法修改spfile，可以通过修改pfile达到目的：</p>

<pre class="line-numbers"><code class="language-sql">SQL&gt; create pfile =&#39;/home/oracle/yourname.ora&#39; from spfile;
SQL&gt; !echo &#39;*.memory_target=2048m&#39; &gt;&gt;&#39;/home/oracle/yourname.ora&#39;; 该命令可以通过vim手动修改/home/oracle/youname.ora替代
</code></pre>

<p>新建pfile并将pfile里面的memory_target设置成2G，一定要验证：<code>memory_target &gt;= sga_target + pga_aggregate_target</code></p>

<h2 id="toc_1">若是操作系统<code>/dev/shm</code>小于<code>memory_target</code>会报以下错误：</h2>

<p><code>ORA-00845: MEMORY_TARGET not supported on this system</code></p>

<p>解决办法：<br/>
<code>Oracle</code>在官方文档中有过说明。解决这个问题只有两个方法，一种是修改初始化参数，使得初始化参数中<code>SGA</code>的设置小于<code>/dev/shm</code>的大小，另一种方法就是调整<code>/dev/shm</code>的大小。</p>

<p>以下记录调整<code>/dev/shm</code>大小方法：</p>

<ul>
<li>修改<code>/etc/fstab</code>达到永久修改：</li>
</ul>

<pre class="line-numbers"><code class="language-bash">[root@cc ~]# vi /etc/fstab
LABEL=/ / ext3 defaults 1 1
LABEL=/boot /boot ext3 defaults 1 2
LABEL=/data /data ext3 defaults 1 2
devpts /dev/pts devpts gid=5,mode=620 0 0
# tmpfs /dev/shm tmpfs defaults 0 0
tmpfs /dev/shm tmpfs defaults,size=4096M 0 0
tmpfs /dev/shm tmpfs defaults,size=10240M 0 0
LABEL=/home /home ext3 defaults 1 2
LABEL=SWAP-sda8 swap swap defaults 0 0
</code></pre>

<ul>
<li>重新挂载<code>/dev/shm</code>，临时修改：</li>
</ul>

<pre class="line-numbers"><code class="language-bash">[root@cc ~]# umount /dev/shm
[root@cc ~]# mount -o remount,size=38g /dev/shm
[root@cc ~]# df -h /dev/shm
</code></pre>

<h2 id="toc_2">启动后再改回从spfile启动</h2>

<pre class="line-numbers"><code class="language-sql">SQL&gt;create spfile from pfile = &#39;/home/oracle/yourname.ora&#39;;

SQL&gt; startup
ORACLE instance started.
Total System Global Area 1068937216 bytes
Fixed Size                  2151248 bytes
Variable Size             511708336 bytes
Database Buffers          549453824 bytes
Redo Buffers                5623808 bytes
Database mounted.
Database opened.
</code></pre>

<p>启动后也可以通过命令验证sga和pga大小：</p>

<pre class="line-numbers"><code class="language-sql">SQL&gt; show parameter target;
NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
archive_lag_target                   integer     0
db_flashback_retention_target        integer     1440
fast_start_io_target                 integer     0
fast_start_mttr_target               integer     0
memory_max_target                    big integer 1300M
memory_target                        big integer 1224M
pga_aggregate_target                 big integer 0
sga_target                           big integer 0
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle 12C PDC基础]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640631.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640631.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">查看pdb开启状态</h2>

<p><code>select con_id, dbid, guid, name , open_mode from v$pdbs;</code></p>

<h2 id="toc_1">建立连接</h2>

<h3 id="toc_2">进入cdb</h3>

<pre class="line-numbers"><code class="language-text">sqlplus /nolog
conn sys/sys as dba
sqlplus sys/sys@localhost:1521/orcl as sysdba
</code></pre>

<h3 id="toc_3">进入pdb</h3>

<p>pdb可以通过alter session container进入，也可以直接通过tns方式（如下）登录<br/>
<code>sqlplus sys/sys@localhost:1521/pdborcl as sysdba</code></p>

<span id="more"></span><!-- more -->

<h2 id="toc_4">显示所有的plaggable db</h2>

<p><code>show pdbs;</code>       </p>

<h2 id="toc_5">查看当前连接名称</h2>

<p><code>show con_name;</code>    </p>

<h2 id="toc_6">新建pdb</h2>

<pre class="line-numbers"><code class="language-text">CREATE PLUGGABLE DATABASE xff_db ADMIN USER xff IDENTIFIED BY xifenfei
STORAGE (MAXSIZE 2G MAX_SHARED_TEMP_SIZE 100M)
DEFAULT TABLESPACE xifenfei
DATAFILE &#39;/u01/app/oracle/oradata/xifenfei/xff/xifenfei01.dbf&#39; SIZE 25M AUTOEXTEND ON  5  PATH_PREFIX = &#39;/u01/app/oracle/oradata/xifenfei/xff/&#39;
FILE_NAME_CONVERT = (&#39;/u01/app/oracle/oradata/xifenfei/pdbseed/&#39;, 
&#39;/u01/app/oracle/oradata/xifenfei/xff/&#39;);
#### 删除PDB
DROP PLUGGABLE DATABASE xff_db INCLUDING DATAFILES;
</code></pre>

<h2 id="toc_7">Unplugging PDB</h2>

<p><code>alter pluggable database FF close immediate;</code><br/>
<code>alter  pluggable database ff UNPLUG into &#39;/tmp/ff.xml&#39;;</code></p>

<h2 id="toc_8">Plug Unplugging PDB</h2>

<pre class="line-numbers"><code class="language-text">create pluggable database ff using &#39;/tmp/ff.xml&#39; copy file_name_convert=(&#39;/u01/app/oracle/oradata/xifenfei/FF/&#39;,&#39;/u01/app/oracle/oradata/xff_l/xff&#39;);
exec DBMS_PDB.SYNC_PDB();
</code></pre>

<h2 id="toc_9">启动关闭PDB</h2>

<ul>
<li>pdb的管理可以在cdb中进行也可以在pdb中进行,</li>
<li>如果是cdb中进行,需要PLUGGABLE关键字（如下alter）,</li>
<li>如果是pdb中直接和普通数据库一样(startup/shutdown immediate)</li>
</ul>

<h3 id="toc_10">打开单个pdb</h3>

<p><code>lter pluggable database pdborcl open;</code></p>

<h3 id="toc_11">打开所有pdb</h3>

<p><code>alter pluggable database all open;</code></p>

<h3 id="toc_12">关闭所有pdb</h3>

<p><code>alter pluggable database all close immediate;</code></p>

<h3 id="toc_13">进入pdb</h3>

<pre class="line-numbers"><code class="language-text">alter session set container=pdborcl;
--//
conn sys/sys@localhost:1521/pdborcl as sysdba;
</code></pre>

<h3 id="toc_14">进入cdb</h3>

<pre class="line-numbers"><code class="language-text">alter session set container=cdb$root;
--//
conn / as sysdba;
</code></pre>

<h2 id="toc_15">创建用户</h2>

<ul>
<li>创建用户默认的是container=all,在cdb中只能创建全局用户(c##开头),</li>
<li>会在cdb和所有的pdb中创建该用户(但是pdb中的全局用户需要另外授权才能够在pdb中访问)。</li>
<li>在pdb中只能创建的用户为本地用户</li>
</ul>

<h3 id="toc_16">创建全局用户</h3>

<p><code>create user c##xff identified by xifenfei;</code></p>

<h3 id="toc_17">创建本地用户</h3>

<p><code>alter session set container=pdborcl;</code><br/>
<code>create user xxx identified by 123;</code></p>

<h3 id="toc_18">用户授权</h3>

<ul>
<li>用户授权默认情况下是只会给当前container,在cdb中也可以指定container=all,对所有open的pdb且存在该用户都进行授权</li>
</ul>

<pre class="line-numbers"><code class="language-text">grant connect to c##xff;
grant resource to c##xff container=all
</code></pre>

<h3 id="toc_19">修改参数</h3>

<ul>
<li>在cdb中修改,pdb会继承进去;如果在pdb中修改会覆盖pdb从cdb中继承的参数含义</li>
</ul>

<pre class="line-numbers"><code class="language-text">alter system set open_cursors=500 container=all;
show parameter open_cursors;
alter session set container=pdborcl;
show parameter open_cursors;
--//
alter system set open_cursors=100;
show parameter open_cursors;
conn / as sysdba
show parameter open_cursors;
</code></pre>

<h2 id="toc_20">使用触发器实现PDB自动启动</h2>

<pre class="line-numbers"><code class="language-text">--先连接  
conn / as sysdba  
  
--创建触发器  
CREATE OR REPLACE TRIGGER open_pdbs  
AFTER STARTUP ON DATABASE  
BEGIN  
EXECUTE IMMEDIATE &#39;ALTER PLUGGABLE DATABASE ALL OPEN&#39;;  
END open_pdbs;
\   --sqlplus中结束脚本编写
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle导入数据相关]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640666.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640666.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">sqlldr</h2>

<h2 id="toc_1">概述</h2>

<p>使用SQL Loader工具是将大批量数据导入Oracle效率最高的方法之一，尤其是在将SQL Server/Sybase等数据库升级为Oracle时，使用SQL Loader可以大大的缩短数据迁移的时间。</p>

<h2 id="toc_2">基本步骤</h2>

<p>使用SQL Loader工具迁移数据一般分为三个步骤: </p>

<ol>
<li>生成文本文件。</li>
<li>编写控制文件。</li>
<li>导入的命令。</li>
</ol>

<span id="more"></span><!-- more -->

<h2 id="toc_3">生成文本文件</h2>

<p>对每一种数据库，都建议使用MSSQL提供的DTS工具来生成文本，尤其是含有时间类型的字段的表。导出时通过查询语句导出，而不是Copy Table 的方式，建议将时间字段转换为&#39;YYYY-MM-DD HH24:MI:SS&#39;的格式。必须注意的是，生成文本文件时，最后一列的值不能为NULL。</p>

<h2 id="toc_4">编写控制文件</h2>

<p>控制文件的格式参考: </p>

<pre class="line-numbers"><code class="language-text">LOAD DATA INFILE &quot;D:\t_card_bill.txt&quot;
     APPEND INTO TABLE t_Card_bill FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39;
     (uaccountno,billtype, huafei,serviceno,fee_date date &#39;YYYY-MM-DD HH24:MI:SS&#39;, fee_enddate date &#39;YYYY-MM-DD HH24:MI:SS&#39;, caller_number, called_number, duration)
</code></pre>

<h2 id="toc_5">导入的命令</h2>

<p>导入命令参考：<br/>
<code>sqlldr username/password@database?control=控制文件所在路径\控制文件名 readsize=5000000 bindsize=5000000 rows=1000</code></p>

<p>其中readsize表示每次读入缓冲区的字节数，bindsize表示每次绑定的字节数，一般情况下这两个值设成一致，rows表示每次提交的数据行。</p>

<blockquote>
<p>注意事项</p>
</blockquote>

<ol>
<li>SQL Loader导入时应该删除表的索引，完成导入后再重建索引。</li>
<li>Oracle 8.0.5的可执行文件名为sqlldr80，通过 sqlldr80很可能会出现报（在“控制文件”结尾发现部分记录）的错误，这中情况一般是控制文件的后面有空行引起。在控制文件的最后一个非空格的字符处回车，然后删除后面的空行可以解决。</li>
<li>编写控制文件时，需要注意导入的字段顺序，必须与导出的顺序一致。</li>
</ol>

<h2 id="toc_6">多线程导入导出dmp</h2>

<pre class="line-numbers"><code class="language-text">expdp sqmdb/mdasill@sqmmt directory=dmpdir tablespaces=sqmdb_rpt dumpfile=sqmdb_rpt_yb%U.dmp filesize=500M parallel=8
dumpfile=sqmdb_rpt_yb%U.dmp filesize=500M parallel=8
 
impdp sqmdb/mdasil@sqmmt tablespaces=sqmdb_rpt directory=dmpdir dumpfile=sqmdb_rpt_yb%U.dmp parallel=8
tablespaces=sqmdb_rpt directory=dmpdir dumpfile=sqmdb_rpt_yb%U.dmp parallel=8
</code></pre>

<h2 id="toc_7">sqlldr导入CSV格式文件入oracle库注意事项</h2>

<h3 id="toc_8">易出现问题：</h3>

<ul>
<li>需要导入的CSV文件换行有问题。 <code>ORA 01722</code></li>
</ul>

<p>CSV文件从windows传到oracle服务器默认格式为dos，如果导入过程中发现报错：ORA 01722，请修改CSV文件格式进行尝试：<code>vi *.csv；set ff=unix；</code></p>

<ul>
<li>CSV文件格式问题</li>
</ul>

<p>使用sqlldr导CSV文件时CSV文件应该去除字段头。</p>

<ul>
<li>导入日志中发现报错 <code>ORA-01861</code></li>
</ul>

<p>处理方法 格式化日期 <br/>
例如：<br/>
<code>TRAILING NULLCOLS *************</code>表的字段没有对应的值时允许为空</p>

<ul>
<li>输入导入命令时出现：<code>SQL*Loader-522</code></li>
</ul>

<p>这种情况一般为权限不够， Linux下使用sqlldr进行批量操作，此操作会自动生成和删除临时文件。 因此，当前操作的用户必须具备对存放文件的文件夹有增删改的权限。chmod 777 文件夹。</p>

<ul>
<li>导入日志发现报错 <code>ORA-01843</code></li>
</ul>

<p>请查看导出CSV文件的数据库<code>NLS_DATE_LANGUAGE、NLS_DATE_FORMAT</code>等是否与目标数据库是否一致，这种情况一般为CSV文件中日期类型中日期中英文与目标数据库不一致。<br/>
会话级别修改: <code>alter session set NLS_DATE_LANGUAGE=&#39;SIMPLIFIED CHINESE&#39;;</code><br/>
系统级别修改（重启数据库生效）: <code>alter system set NLS_DATE_LANGUAGE=&#39;AMERICAN&#39; scope = spfile;</code><br/>
<code>vim ~/.bash_profile : export NLS_LANG=AMERICAN_AMERICA.ZHS16GBK</code></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle常规函数]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640706.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640706.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">数值型常用函数</h2>

<ol>
<li><p>ceil(n)</p>
<p>大于或等于数值n的最小整数<br/>
<code>select ceil(10.6) from dual; 11</code></p></li>
<li><p>floor(n)</p>
<p>小于等于数值n的最大整数　<br/>
<code>select ceil(10.6) from dual; 10</code></p></li>
<li><p>mod(m,n)</p>
<p>m除以n的余数,若n=0,则返回m <br/>
<code>select mod(7,5) from dual; 2</code></p></li>
<li><p>power(m,n)</p>
<p>m的n次方<br/>
<code>select power(3,2) from dual; 9</code></p></li>
<li><p>round(n,m)</p>
<p>将n四舍五入,保留小数点后m位,省掉m就是到整数，m是负数就是小数点 前几位</p>
<pre class="line-numbers"><code class="language-sql">SELECT round(23.75123) FROM dual;　 --返回23
select round(1234.5678,2) from dual; 1234.57<br/>
SELECT round(23.75123, -1) FROM dual; --返回20
</code></pre></li>
<li><p>trunc(n,[m])</p>
<p>该函数用于截取数字。<br/>
如果省掉m，就截去小数部分，<br/>
如果m是正数就截取到小数点的m位后，<br/>
如果m是负数，则截取到小数点的前m位。<br/>
<code>SELECT trunc(23.75123) FROM dual; --返回23</code><br/>
<code>SELECT trunc(23.75123, -1) FROM dual; --返回20</code><br/>
<code>SELECT trunc(23.75123, 1) FROM dual; --返回23.7</code></p></li>
</ol>

<span id="more"></span><!-- more -->

<ol>
<li><p>sign(n) </p>
<p>若n=0,则返回,否则,n&gt;0,则返回,n&lt;0,则返回-1 <br/>
select sign(12) from dual; 1</p></li>
<li><p>sqrt(n) </p>
<p>n的平方根<br/>
select sqrt(25) from dual ; 5</p></li>
<li><p>nvl</p>
<p>select nvl(1,&#39;a&#39;) from dual;相当于isnull</p></li>
</ol>

<h2 id="toc_1">常用字符函数</h2>

<ol>
<li><p>initcap(char) </p>
<p>把每个字符串的第一个字符换成大写　　<br/>
select initicap(&#39;mr.ecop&#39;) from dual; Mr.Ecop</p></li>
<li><p>lower(char) </p>
<p>整个字符串换成小写　　　　　　　　　<br/>
select lower(&#39;MR.ecop&#39;) from dual; mr.ecop</p></li>
<li><p>UPPER(string)</p>
<p>返回大写的“string”。<br/>
示例 SELECT UPPER(&#39;aptech computer education&#39;) FROM dual;</p></li>
<li><p>replace(char,str1,str2) </p>
<p>字符串中所有str1换成str2 <br/>
select replace(&#39;Scott&#39;,&#39;s&#39;,&#39;Boy&#39;) from dual; Boycott</p></li>
<li><p>substr(char,m,n) </p>
<p>取出从m字符开始的n个字符的子串,如果我们不指定n，则从m开始截取到string的尾部　<br/>
如果m为负数就是从左开始数.　<br/>
select substr(&#39;ABCDEF&#39;,2,2) from dual; CD<br/>
select substr(&#39;1234567&#39;,-3,2) from dual;56</p></li>
<li><p>length(char) <br/>
求字符串的长度　　　　<br/>
select length(&#39;ACD&#39;) from dual; 3</p></li>
<li><p>vsize<br/>
select vsize(&#39;HELLO21可&#39;) from dual;9<br/>
select length(&#39;HELLO21可&#39;) from dual;8</p></li>
<li><p>|| <br/>
并置运算符　　　<br/>
select &#39;ABCD&#39;||&#39;EFGH&#39; from dual; ABCDEFGH</p></li>
<li><p>CONCAT (char1, char2)<br/>
返回连接“char2”的“char1”。<br/>
SELECT CONCAT(&#39;zq_&#39;, &#39;test&#39;) FROM dual; zq_test</p></li>
<li><p>LPAD(char1,n [,char2])<br/>
返回“char1”，左起由“char2”中的字符补充到“n”个字符长。如果“char1”比“n”长，则函数返回“char1”的前“n”个字符。<br/>
示例 SELECT LPAD(ename,15,&#39;*&#39;) FROM emp;<br/>
SELECT lpad(&#39;zqtest&#39;,2,&#39;a&#39;) FROM dual; zq<br/>
SELECT lpad(&#39;zqtest&#39;,10,&#39;a&#39;) FROM dual; aaaazqtest</p></li>
<li><p>RPAD(char1, n [,char2])<br/>
返回“char1”，右侧用“char2”中的字符补充到“n”个字符长。如果 “char1”比“n”长，则函数返回“char1”的前“n”个字符。<br/>
示例 SELECT RPAD(ename,15,&#39;*&#39;) FROM emp;</p></li>
<li><p>LTRIM(string,trim_set)<br/>
从左边删除字符，此处“string”是数据库的列，或者是字面字符串，而“trim_set”是我们要去掉的字符的集合。<br/>
示例 SELECT LTRIM(&#39;abcdab&#39;,&#39;a&#39;) FROM DUAL;</p></li>
<li><p>RTRIM(string,trim_set)<br/>
从右侧删除字符，此处“string”是数据库的列，或者是字面字符串，而“trim_set”是我们要去掉的字符的集合。<br/>
示例 SELECT RTRIM(&#39;abcdef&#39;, &#39;f&#39;) FROM DUAL;</p></li>
<li><p>SOUNDEX(char)<br/>
返回包含“char”的表意字符的字符串。它允许比较英语中拼写不同而发音类似的字。<br/>
示例 SELECT ename FROM emp<br/>
WHERE SOUNDEX(ename) = SoUNDEX(&#39;SMYTHE&#39;);</p></li>
<li><p>TRANSLATE(string, if, then)<br/>
“if”中字符的位置，并检查“then”的相同位置，然后用该位置的字符替换 “string”中的字符。<br/>
示例 SELECT TRANSLATE(ename,&#39;AEIOU&#39;, &#39;XXXXX&#39;) FROM emp;<br/>
SELECT TRANSLATE(&#39;abcdef&#39;, &#39;ef&#39;,&#39;zz&#39;) FROM DUAL; abcdzz</p></li>
<li><p>ASCII(string)<br/>
该命令是“American Standard Code for Information Interchange”的缩写。它是使用数字表示可打印字符的基本规则。该函数返回 “string”中第一个（最左边）字符的 ASCII 值。<br/>
示例 SELECT ASCII(&#39;APTECH&#39;) from dual;</p></li>
<li><p>INSTR (string, set[, start[, occurrence] ] )<br/>
该命令“string”中从“start”位置开始查找字符集合的位置，再查找“set”出现的第一次、第二次等等的“occurrence”（次数）。“start”的值也可以是负数，代表从字符串结尾开始向反方向搜索。该函数也用于数字和日期数据类型。<br/>
select instr(&#39;azhangsanbcd&#39;, &#39;zhangsan&#39;) from dual; --返回2<br/>
select instr(&#39;oracle traning&#39;, &#39;ra&#39;, 1, 1) instring from dual; --返回2<br/>
select instr(&#39;oracle traning&#39;, &#39;ra&#39;, 1, 2) instring from dual; --返回9<br/>
select instr(&#39;oracle traning&#39;, &#39;ra&#39;, 1, 3) instring from dual; --返回0，根据条件，由于ra只出现二次，第四个参数，就是说第次出现ra的位置，显然第3次是没有再出现了，所以结果返回。注意空格也算一个字符<br/>
select instr(&#39;abc&#39;,&#39;d&#39;) from dual;  --返回0</p></li>
<li><p>获取字符串中某个字符的个数regexp_count<br/>
select regexp_count(group_imsi,&#39;,&#39;)+1 as imsi_num,<br/>
seq,startdate,enddate <br/>
from t_complain_imsi_history t order by seq desc</p></li>
<li><p>日期型函数</p></li>
<li><p>sysdate <br/>
当前日期和时间 <br/>
select sysdate from dual;</p></li>
<li><p>last_day 　<br/>
本月最后一天 <br/>
select last_day(sysdate) from dual; 2014/7/31 17:14:43</p></li>
<li><p>add_months(d,n)　<br/>
当前日期d后推n个月 <br/>
select add_months(sysdate,2) from dual; 2014/9/17 17:16:44</p></li>
<li><p>months_between(d,n)<br/>
日期d和n相差月数 <br/>
select months_between(sysdate,to_date(&#39;20140817&#39;,&#39;YYYYMMDD&#39;)) from dual; -1</p></li>
<li><p>next_day(d,day) <br/>
返回下一个星期第几天的日期。美国是从周日开算的。next_day(sysdate,6)是从当前开始下一个星期五<br/>
select next_day(sysdate,1) from dual; </p></li>
<li><p>特殊格式的日期型函数(格式)<br/>
Y或YY或YYY 年的最后一位，两位，三位 select to_char(sysdate,&#39;YYY&#39;) from dual;<br/>
Q 季度,1-3月为第一季度　　　　      select to_char(sysdate,&#39;Q&#39;) from dual;<br/>
MM 　月份数　　　　　　　　　　　    select to_char(sysdate,&#39;MM&#39;) from dual;<br/>
RM 月份的罗马表示                   select to_char(sysdate,&#39;RM&#39;) from dual; IV<br/>
month 用个字符表示的月份名         select to_char(sysdate,&#39;month&#39;) from dual;<br/>
ww 当年第几周　　　　　　　　　     select to_char(sysdate,&#39;ww&#39;) from dual;<br/>
w 本月第几周　　　　　　　　　      select to_char(sysdate,&#39;w&#39;) from dual;<br/>
DDD 当年第几天,一月一日为,二月一日 select to_char(sysdate,&#39;DDD&#39;) from dual;<br/>
DD 当月第几天       select to_char(sysdate,&#39;DD&#39;) from dual;<br/>
D 周内第几天     select to_char(sysdate,&#39;D&#39;) from dual; 如　sunday<br/>
DY 周内第几天缩写　　　　　　　select to_char(sysdate,&#39;DY&#39;) from dual; 如　sun<br/>
hh12 12小时制小时数　　　　　　　select to_char(sysdate,&#39;hh12&#39;) from dual;<br/>
hh24 24小时制小时数　　　　　　　select to_char(sysdate,&#39;hh24&#39;) from dual;<br/>
Mi 分钟数　　　　　　　　　　　select to_char(sysdate,&#39;Mi&#39;) from dual;<br/>
ss 秒数　　　　　　　　　　　　select to_char(sysdate,&#39;ss&#39;) from dual;<br/>
select to_char(sysdate,&#39;YYYY-MM-DD HH:24:mi:ss&#39;) from dual;</p></li>
<li><p>时间加减<br/>
select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),to_char(sysdate+n<em>365,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual        //改变时间-年<br/>
select add_months(sysdate,n) as newTime from dual                                 //改变时间-月<br/>
select to_char(sysdate+n,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual       //改变时间-日<br/>
select to_char(sysdate+n/24,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual    //改变时间-时<br/>
select to_char(sysdate+n/24/60,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual  //改变时间-分<br/>
select to_char(sysdate+n/24/60/60,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual;//改变时间-秒<br/>
返回星期几<br/>
select to_char(to_date(&#39;2002-08-26&#39;,&#39;yyyy-mm-dd&#39;),&#39;day&#39;) from dual; 星期一<br/><br/>
select to_char(to_date(&#39;2002-08-26&#39;,&#39;yyyy-mm-dd&#39;),&#39;day&#39;,&#39;NLS_DATE_LANGUAGE = American&#39;) from dual; monday<br/><br/>
间隔天数<br/>
select floor(sysdate - to_date(&#39;20020405&#39;,&#39;yyyymmdd&#39;)) from dual;<br/>
 查找2002-02-28至2002-02-01间除星期六和七的天数，美国是周日第一天<br/>
select count(</em>) from ( select rownum-1 rnum from all_objects<br/><br/>
   where rownum &lt;= to_date(&#39;2002-02-28&#39;,&#39;yyyy-mm-dd&#39;) - to_date(&#39;2002-02-01&#39;,&#39;yyyy-mm-dd&#39;)+1<br/><br/>
    ) where to_char( to_date(&#39;2002-02-01&#39;,&#39;yyyy-mm-dd&#39;)+rnum-1, &#39;D&#39; ) not in ( &#39;1&#39;, &#39;7&#39; )  </p></li>
<li><p>日期转换毫秒<br/>
SELECT TO_NUMBER(TO_DATE(&#39;2005-03-29 12:30:45&#39;, &#39;YYYY-MM-DD HH24:MI:SS&#39;) -<br/><br/>
             TO_DATE(&#39;1970-01-01 8:0:0&#39;, &#39;YYYY-MM-DD HH24:MI:SS&#39;)) * 24 * 60 * 60 * 1000<br/><br/>
FROM DUAL;<br/><br/>
 <br/>
 <br/>
--毫秒转换日期<br/>
 <br/>
 <br/>
SELECT TO_CHAR(1112070645000 / (1000 * 60 * 60 * 24) +<br/><br/>
    TO_DATE(&#39;1970-01-01 08:00:00&#39;, &#39;YYYY-MM-DD HH:MI:SS&#39;), &#39;YYYY-MM-DD HH:MI:SS&#39;) AS CDATE<br/><br/>
FROM DUAL;<br/><br/>
SELECT TO_CHAR(1112070645123 / (1000 * 60 * 60 * 24) +<br/><br/>
    TO_DATE(&#39;1970-01-01 08:00:00&#39;, &#39;YYYY-MM-DD HH:MI:SS&#39;), &#39;YYYY-MM-DD HH:MI:SS&#39;)||&#39;.&#39;||substr(1112070645123,-3) AS CDATE<br/><br/>
FROM DUAL;  </p></li>
</ol>

<p>CREATE OR REPLACE FUNCTION msToTimestamp(I_MILLISECONDS NUMBER)<br/>
 RETURN varchar2 AS<br/>
  V_TIMESTAMPSTR VARCHAR2(40);<br/>
BEGIN<br/>
  select TO_CHAR(substr(I_MILLISECONDS,1,length(I_MILLISECONDS)-3) / ( 60 * 60 * 24) +TO_DATE(&#39;1970-01-01 08:00:00&#39;, &#39;YYYY-MM-DD HH24:MI:SS&#39;), &#39;YYYY-MM-DD HH24:MI:SS&#39;)||&#39;.&#39;||substr(I_MILLISECONDS,-3)<br/>
  into V_TIMESTAMPSTR<br/>
  from dual;<br/>
  RETURN V_TIMESTAMPSTR;<br/>
EXCEPTION<br/>
  WHEN OTHERS THEN<br/>
    RETURN NULL;<br/>
END;</p>

<ol>
<li>周、月、季开始结束时间<br/>
--周<br/>
SELECT TRUNC(TO_DATE(&#39;2013-11-25 10:31:11&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;),&#39;D&#39;) + 1 ASA FROM DUAL;<br/>
SELECT TRUNC(sysdate,&#39;D&#39;) + 7 AS A FROM DUAL;<br/>
获取今天是周几<br/>
select to_char(sysdate,&#39;day&#39;,&#39;NLS_DATE_LANGUAGE=AMERICAN&#39;) day from dual;<br/>
--月<br/>
SELECT TRUNC(TO_DATE(&#39;2013-11-25 10:31:11&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;),&#39;MM&#39;) AS A FROM DUAL;<br/>
SELECT LAST_DAY(TO_DATE(&#39;2013-11-25 10:31:11&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;)) AS A FROM DUAL;<br/>
--季<br/>
SELECT TRUNC(TO_DATE(&#39;2013-11-25 10:31:11&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;),&#39;Q&#39;) AS A FROM DUAL;<br/>
SELECT ADD_MONTHS(TRUNC(TO_DATE(&#39;2013-11-25 10:31:11&#39;,&#39;YYYY-MM-DDHH24:MI:SS&#39;),&#39;Q&#39;),3)-1 AS A FROM DUAL;</li>
<li>timestamp 计算毫秒差<br/>
create or replace function diffTimestamp(s in TIMESTAMP, e in TIMESTAMP)<br/>
return number is<br/>
Result number;<br/>
begin<br/>
select extract(day from inter) * 24 * 60 * 60*1000 +<br/>
     extract(hour from inter) * 60 * 60*1000 +<br/>
     extract(minute from inter) * 60*1000 +<br/>
     extract(second from inter) * 1000 &quot;mseconds&quot;<br/>
INTO Result<br/>
from (select e - s inter from dual);<br/>
return(Result);<br/>
end diffTimestamp;</li>
</ol>

<p>实例</p>

<ol>
<li>循环取出表的行<br/>
begin<br/>
for zqtest in (select column_value c_code from table(pkg_public.splitstring(&#39;1,2,3,4,5,6&#39;, &#39;,&#39;))) loop<br/>
   dbms_output.put_line(zqtest.c_code);<br/>
end loop;<br/>
end;<br/>
declare <br/>
v_sql varchar2(500);<br/>
num number;<br/>
begin<br/>
for zqtest in (select table_name from user_tables where table_name like&#39;DW_%&#39; and table_name not like&#39;%_D&#39; and table_name&lt;&gt;’DW_FT_SE_CL3_US_AN_60_H’) loop<br/>
   v_sql:=&#39;select count(*) from &#39;||zqtest.table_name||&#39; where rpt_time&gt;=trunc(sysdate,&#39;&#39;dd&#39;&#39;) <br/>
and  rpt_time&lt;trunc(sysdate+1,&#39;&#39;dd&#39;&#39;) and rownum=1&#39;;<br/>
    execute immediate v_sql into num;<br/>
   if num=0 then <br/>
   dbms_output.put_line(zqtest.table_name);<br/>
   end if;<br/>
end loop;<br/>
end;</li>
<li>建立分区表<br/>
CREATE TABLE SQMDB.RTP_HTTP_USER_PEAK_AREA_D<br/>
(<br/>
  SDATE            DATE,<br/>
  AREA             VARCHAR2(20 BYTE),<br/>
  PEAKHOUR         NUMBER,<br/>
  NO_OF_HTTP_SUCC  NUMBER,<br/>
  NO_OF_USER       NUMBER,<br/>
  APP              VARCHAR2(50 BYTE),<br/>
  NETWORK_TYPE     NUMBER<br/>
)<br/>
TABLESPACE SQM_OTHER<br/>
PARTITION BY RANGE (SDATE)<br/>
INTERVAL( NUMTODSINTERVAL(1,&#39;DAY&#39;))<br/>
(  <br/>
  PARTITION PART_INIT VALUES LESS THAN (TO_DATE(&#39; 2016-01-01 00:00:00&#39;, &#39;SYYYY-MM-DD HH24:MI:SS&#39;, &#39;NLS_CALENDAR=GREGORIAN&#39;))<br/>
    NOLOGGING<br/>
    NOCOMPRESS <br/>
    TABLESPACE SQM_OTHER<br/>
)<br/>
NOCACHE<br/>
NOPARALLEL<br/>
MONITORING; </li>
</ol>

<p>TABLESPACE sqm_volte_i<br/>
PARTITION BY RANGE (s1_endtime)<br/>
INTERVAL( NUMTODSINTERVAL(1,&#39;Hour&#39;))<br/>
(<br/><br/>
 partition PART_INIT values less than (TIMESTAMP&#39; 2016-01-01 00:00:00&#39;)<br/>
    NOLOGGING<br/>
    NOCOMPRESS <br/>
    TABLESPACE sqm_volte_i<br/>
)<br/>
NOCACHE<br/>
NOPARALLEL<br/>
MONITORING;</p>

<ol>
<li>游标<br/>
declare <br/>
   --类型定义<br/>
   cursor c_job<br/>
   is<br/>
   select imsi, ts, ci  from v_zqtest_imsici;<br/>
   --定义一个游标变量<br/>
   c_row c_job%rowtype;<br/>
begin<br/>
   open c_job;<br/>
     loop<br/>
       --提取一行数据到c_row<br/>
       fetch c_job into c_row;<br/>
       --判读是否提取到值，没取到值就退出<br/>
       --取到值c_job%notfound 是false <br/>
       --取不到值c_job%notfound 是true<br/>
       exit when c_job%notfound;<br/>
        dbms_output.put_line(c_row.ts||&#39;-&#39;||c_row.imsi||&#39;-&#39;||c_row.ci||&#39;-&#39;||c_row.ci);<br/>
     end loop;<br/>
   --关闭游标<br/>
  close c_job;<br/>
end;</li>
<li><p>判断表名是否存在<br/>
declare<br/><br/>
    num   number;<br/><br/>
begin<br/><br/>
    select count(1) into num from all_tables where TABLE_NAME = upper(&#39;zqtest_pingpeng_gb&#39;) and OWNER=&#39;DAILY&#39;;<br/><br/>
    if   num=1   then<br/><br/>
        execute immediate &#39;drop table zqtest_pingpeng_gb&#39;;<br/><br/>
    end   if;      </p>
<p>end;   </p></li>
<li><p>建立DBLink<br/>
CREATE PUBLIC DATABASE LINK SQMDB<br/>
CONNECT TO sqmdb<br/>
IDENTIFIED BY mdasil<br/>
USING &#39;127.0.0.1:1521/sqmmt2&#39;;<br/>
select * from cfg_customer_group@SQMDB;</p></li>
<li><p>row_number()和 dense_rank()和rank()区别<br/>
SQL&gt; select region_id, customer_id, sum(customer_sales) total,<br/>
  2         rank() over(order by sum(customer_sales) desc) rank,<br/>
  3         dense_rank() over(order by sum(customer_sales) desc nulls last) dense_rank,<br/>
  4         row_number() over(order by sum(customer_sales) desc nulls first) row_number<br/>
  5    from user_order<br/>
  6   group by region_id, customer_id;</p></li>
</ol>

<p> REGION_ID CUSTOMER_ID      TOTAL       RANK DENSE_RANK ROW_NUMBER<br/>
---------- ----------- ---------- ---------- ---------- ----------<br/>
            <br/>
         8          18                1253840         11         11         11<br/>
         5           2                 1224992         12         12         12<br/>
         9          23                1224992         12         12         13<br/>
         9          24                1224992         12         12         14<br/>
        10          30               1216858         15           13            15<br/>
SQL&gt; select region_id, customer_id, <br/>
               sum(customer_sales) total,<br/>
  2         rank() over(partition by region_id<br/>
                        order by sum(customer_sales) desc) rank,<br/>
  3         dense_rank() over(partition by region_id<br/>
                        order by sum(customer_sales) desc) dense_rank,<br/>
  4         row_number() over(partition by region_id<br/>
                        order by sum(customer_sales) desc) row_number<br/>
  5    from user_order<br/>
  6   group by region_id, customer_id;</p>

<p> REGION_ID CUSTOMER_ID      TOTAL       RANK DENSE_RANK ROW_NUMBER<br/>
---------- ----------- ---------- ---------- ---------- ----------<br/>
         5           4                1878275          1          1          1<br/>
         5           2                1224992          2          2          2<br/>
         5           5                1169926          3          3          3<br/>
         6           6                1788836          1          1          1<br/>
         6           9                1208959          2          2          2<br/>
         6          10               1196748          3          3          3       </p>

<ol>
<li>找最大最小行 min() keep( dense_rank first)<br/>
select a.imsi,b.road_line,<br/>
       min(a.procedure_start_time) keep(dense_rank first ORDER BY a.procedure_start_time) over(PARTITION BY a.imsi,b.road_line) ts1,<br/>
       MIN(a.cell_id) keep(dense_rank first ORDER BY a.procedure_start_time) over(PARTITION BY a.imsi,b.road_line) ci1,<br/>
       max(a.procedure_start_time) keep(dense_rank last ORDER BY a.procedure_start_time) over(PARTITION BY a.imsi,b.road_line) ts2,<br/>
       max(a.cell_id) keep(dense_rank last ORDER BY a.procedure_start_time) over(PARTITION BY a.imsi,b.road_line) ci2,<br/>
       row_number() over(partition by a.imsi,b.road_line order by a.procedure_start_time desc) rn<br/>
  from zqtest_XDR_S1_MME a,zqtest_imsilist b,zqtest_cilist c</li>
<li>找前一行 lag后一行 lead<br/>
with dat as <br/>
(<br/>
select 1 as s_id,&#39;a&#39; as s_type,&#39;1aaa&#39; as s_name from dual union all<br/>
select 2 as s_id,&#39;a&#39; as s_type,&#39;2aaa&#39; as s_name from dual union all<br/>
select 3 as s_id,&#39;a&#39; as s_type,&#39;3aaa&#39; as s_name from dual union all<br/>
select 4 as s_id,&#39;a&#39; as s_type,&#39;4aaa&#39; as s_name from dual union all<br/>
select 5 as s_id,&#39;a&#39; as s_type,&#39;5aaa&#39; as s_name from dual union all<br/>
select 1 as s_id,&#39;b&#39; as s_type,&#39;1bbb&#39; as s_name from dual union all<br/>
select 2 as s_id,&#39;b&#39; as s_type,&#39;2bbb&#39; as s_name from dual union all<br/>
select 3 as s_id,&#39;b&#39; as s_type,&#39;3bbb&#39; as s_name from dual <br/>
)<br/>
select s_id,s_type,s_name,<br/>
lag(s_name,1,&#39;最大了&#39;) over(partition by s_type order by s_id desc) as 前一行,<br/>
lead(s_name,1,&#39;最小了&#39;) over(partition by s_type order by s_id desc) as  后一行<br/>
from dat</li>
<li>ratio_to_report 算占比<br/>
with dat as <br/>
(<br/>
select 1 as s_id,&#39;a&#39; as s_type,&#39;1aaa&#39; as s_name from dual union all<br/>
select 2 as s_id,&#39;a&#39; as s_type,&#39;1aaa&#39; as s_name from dual union all<br/>
select 3 as s_id,&#39;a&#39; as s_type,&#39;1aaa&#39; as s_name from dual union all<br/>
select 4 as s_id,&#39;a&#39; as s_type,&#39;4aaa&#39; as s_name from dual union all<br/>
select 5 as s_id,&#39;a&#39; as s_type,&#39;5aaa&#39; as s_name from dual union all<br/>
select 1 as s_id,&#39;b&#39; as s_type,&#39;1bbb&#39; as s_name from dual union all<br/>
select 2 as s_id,&#39;b&#39; as s_type,&#39;1bbb&#39; as s_name from dual union all<br/>
select 3 as s_id,&#39;b&#39; as s_type,&#39;3bbb&#39; as s_name from dual <br/>
)<br/>
select s_id,s_type,s_name,<br/>
round(ratio_to_report(s_id) over(partition by s_type,s_name)*100,2) from dat</li>
<li><p>查找所有表去掉小时重表<br/>
select table_name from ( <br/>
select <br/>
rtrim( table_name, &#39;0123456789_&#39;) as table_name<br/>
from user_tables where table_name not like&#39;TEMP%&#39; and table_name not like&#39;%TEMP&#39;<br/>
) group by table_name</p></li>
<li><p>停tomcat，看进程<br/>
ps -ef | grep tomcat</p></li>
<li><p>新建用户<br/>
CREATE USER RTDB<br/>
IDENTIFIED BY mdasil --密码<br/>
DEFAULT TABLESPACE RTDB--空间要先建立<br/>
TEMPORARY TABLESPACE other_temp --临时空间要改<br/>
PROFILE DEFAULT<br/>
ACCOUNT UNLOCK;<br/>
-- 5 Roles for RTDB <br/>
GRANT AQ_ADMINISTRATOR_ROLE TO RTDB WITH ADMIN OPTION;<br/>
GRANT CONNECT TO RTDB WITH ADMIN OPTION;<br/>
GRANT DBA TO RTDB WITH ADMIN OPTION;<br/>
GRANT MGMT_USER TO RTDB;<br/>
GRANT RESOURCE TO RTDB WITH ADMIN OPTION;<br/>
ALTER USER RTDB DEFAULT ROLE ALL;<br/>
-- 25 System Privileges for RTDB <br/>
GRANT ADMINISTER ANY SQL TUNING SET TO RTDB WITH ADMIN OPTION;<br/>
GRANT ADMINISTER DATABASE TRIGGER TO RTDB WITH ADMIN OPTION;<br/>
GRANT ADMINISTER SQL TUNING SET TO RTDB WITH ADMIN OPTION;<br/>
GRANT ALTER ANY TRIGGER TO RTDB WITH ADMIN OPTION;<br/>
GRANT CREATE ANY PROCEDURE TO RTDB WITH ADMIN OPTION;<br/>
GRANT CREATE ANY TABLE TO RTDB WITH ADMIN OPTION;<br/>
GRANT CREATE ANY TRIGGER TO RTDB WITH ADMIN OPTION;<br/>
GRANT CREATE ANY VIEW TO RTDB WITH ADMIN OPTION;<br/>
GRANT CREATE MATERIALIZED VIEW TO RTDB;<br/>
GRANT CREATE PROCEDURE TO RTDB;<br/>
GRANT CREATE SEQUENCE TO RTDB;<br/>
GRANT CREATE SESSION TO RTDB WITH ADMIN OPTION;<br/>
GRANT CREATE TABLE TO RTDB;<br/>
GRANT CREATE TRIGGER TO RTDB;<br/>
GRANT CREATE VIEW TO RTDB;<br/>
GRANT DELETE ANY TABLE TO RTDB WITH ADMIN OPTION;<br/>
GRANT DROP ANY TABLE TO RTDB;<br/>
GRANT DROP ANY VIEW TO RTDB;<br/>
GRANT EXECUTE ANY CLASS TO RTDB WITH ADMIN OPTION;<br/>
GRANT EXECUTE ANY PROCEDURE TO RTDB WITH ADMIN OPTION;<br/>
GRANT GLOBAL QUERY REWRITE TO RTDB;<br/>
GRANT INSERT ANY TABLE TO RTDB WITH ADMIN OPTION;<br/>
GRANT SELECT ANY TABLE TO RTDB WITH ADMIN OPTION;<br/>
GRANT UNLIMITED TABLESPACE TO RTDB WITH ADMIN OPTION;<br/>
GRANT UPDATE ANY TABLE TO RTDB WITH ADMIN OPTION;</p></li>
<li><p>导入导出数据结构<br/>
create or replace directory UTL_FILE_DIR as &#39;/opt/oracle/utl_file&#39;; --建立directory<br/>
select * from dba_directories –查询directory<br/>
export ORACLE_SID=sqmmt23g 指定实例<br/>
echo $ORACLE_SID　显示当前实例<br/>
expdp sqmdb/mdasil schemas=sqmdb directory=dmpdir dumpfile=sqmdb1016.dmp content=metadata_only<br/>
impdp rtdb/mdasil schemas=rtdb directory=dmpdir dumpfile=zqtest_1031.dmp<br/>
导出所有cfg和sch开头的表，并去掉其中的CFG_CUSTOMER_GROUP_H表的数<br/>
expdp sqmdb/mdasil tables=CFG%,SCH% directory=dmpdir dumpfile=sqmdb_data1118.dmp exclude=table:&quot;like&#39;CFG_CUSTOMER_GROUP_H&#39;&quot;<br/>
impdp sqmdb/mdasil directory=DATA_PUMP_DIR dumpfile=sqmdb_data1118.dmp TABLE_EXISTS_ACTION=append</p></li>
</ol>

<p>expdp sqmdb/mdasil schemas=sqmdb directory = dmpdir dumpfile = sqmdb_test.dmp include=table:&quot; in (select table_name from user_tables where table_name like\&#39;RPT_VOLTE%\&#39;or table_name like\&#39;RPT_WLQ_86%\&#39; or table_name like\&#39;CFG_86%\&#39; or table_name like\&#39;CFG_WLQ%\&#39; or table_name like \&#39;CFG_WLQ_ALARM_LIMIT\&#39;)&quot; include = view:&quot;in (select view_name from user_views where view_name like\&#39;V_86%\&#39; or view_name like\&#39;V_WQL%\&#39;  or view_name like\&#39;V_WLQ%\&#39;)&quot; include = procedure:&quot; in (select object_name from user_procedures where object_name like \&#39;SP_86%\&#39; or object_name like \&#39;SP_WQL%\&#39; or object_name like \&#39;SP_WLQ%\&#39; or  object_name like \&#39;SP_IS_TABLE_EXISTS_DBLINK\&#39; or object_name like \&#39;DAILY_VOL_86%\&#39; or object_name like \&#39;DAILY_VOL_WLQ\&#39;)&quot; content=metadata_only<br/>
14. 上传文件<br/>
最近在部署系统时接触了一些文件传输命令，分别做一下简单记录：</p>

<ol>
<li>sftp 是一个交互式文件传输程式。它类似于 ftp, 但它进行加密传输，比FTP有更高的安全性。下边就简单介绍一下如何远程连接主机，进行文件的上传和下载，以及一些相关操作。<br/>
举例，如远程主机的 IP 是 202.206.64.33或者是域名www.hebust.edu.cn,用户名是  fyt ,在命令行模式下:sftp fyt@202.206.64.33或者  <a href="mailto:fyt@www.hebust.edu.cn">fyt@www.hebust.edu.cn</a>。回车提示输入密码。进入提示符sftp&gt;<br/>
如果登陆远程机器不是为了上传下载文件，而是要修改远程主机上的某些文件。可以<br/>
ssh  fyt@202.206.64.33 （其实sftp就是ssh 的一个程式。）<br/>
sftp&gt; get /var/www/fuyatao/index.php  /home/fuyatao/<br/>
这条语句将从远程主机的  /var/www/fuyatao/目录下将 index.php 下载到本地  /home/fuyatao/目录下。<br/>
sftp&gt; put /home/fuyatao/downloads/Linuxgl.pdf /var/www/fuyatao/<br/>
这条语句将把本地 /home/fuyatao/downloads/目录下的 linuxgl.pdf文件上传至远程主机/var/www/fuyatao/ 目录下。<br/>
你如果不知道远程主机的目录是什么样， pwd命令可以帮您查询远程主机的当前路径。查询本机当前工作目录 lpwd.<br/>
改变路径可以用cd ，改变本机路径可以用 lcd;<br/>
ls rm rmdir mkdir 这些命令都可以使用。同理调用本机都是加 l , 即 lls lrm.<br/>
要离开sftp，用exit 或quit、 bye 均可。详细情况可以查阅 man  sftp.<br/>
如果觉得在命令行模式下不太方便，可以 sudo apt-get install gftp。在图形界面下操作就简便多了。<br/>
2.scpSCP ：secure copy (remote file copy program) 也是一个基于SSH安全协议的文件传输命令。与sftp不同的是，它只提供主机间的文件传输功能，没有文件管理的功能。<br/>
复制local_file 到远程目录remote_folder下<br/>
scp local_file remote_user@host:remote_folder<br/>
复制local_folder 到远程remote_folder（需要加参数 -r 递归）<br/>
scp –r local_folder remote_user@host:remote_folder<br/>
以上命令反过来写就是远程复制到本地<br/>
3.sz/rzsz/rz 是基于ZModem传输协议的命令。对传输的数据会进行核查，并且有很好的传输性能。使用起来更是非常方便，但前提是window端需要有能够支持ZModem的telnet或者SSH客户端，例如secureCRT。<br/>
首先需要在secureCRT中可以配置相关的本地下载和上传目录，然后用rz、sz命令即可方便的传输文件数据。<br/>
下载数据到本地下载目录：sz filename1 filename2 …<br/>
上传数据到远程：执行rz –be 命令，客户端会弹出上传窗口，用户自行选择(可多选)要上传的文件即可。</li>
<li>编译存储过程卡死处理<br/>
SELECT * FROM V\(DB_OBJECT_CACHE WHERE name=upper(&#39;sp_user_complain_p0_V_sh&#39;) AND LOCKS!=&#39;0&#39;;  --查看lock数；一般来说是有test没有关完，又同时去改过程造成的。<br/>
select SID from V\)ACCESS WHERE object=upper(&#39;sp_user_complain_p0_V_sh&#39;);<br/>
这句执行太慢，可以用下面这句来找出测试窗口。<br/>
select * <br/>
FROM v\(session a,v\)sqltext c<br/>
WHERE a.sql_address=c.address(+) and action like &#39;%Test%&#39;<br/>
ORDER BY c.piece<br/>
找出对应的sid和serial#；最后杀掉就可以了<br/>
SELECT SID,SERIAL#,PADDR FROM V\(SESSION WHERE SID in (id...)<br/>
SELECT * FROM V\)DB_OBJECT_CACHE WHERE name=upper(&#39;daily_kqi_g1_yn_v2&#39;) AND LOCKS!=&#39;0&#39;<br/>
select sid,sql_text from v\(open_cursor where UPPER(sql_text) like &#39;%DAILY_KQI_G1_YN_V2%&#39;<br/>
SELECT SID,SERIAL#,PADDR FROM V\)SESSION WHERE SID in (360)</li>
<li>在触发器中添v\(sesseion语句.<br/>
这需要用sys用户以sysdba 方式登陆，再执行<br/>
Grant 语句将v_\)seeeion的 select on 权限给对应的用户。</li>
<li><p>导出用户权限<br/>
select dbms_metadata.get_ddl(&#39;USER&#39;,&#39;SQMDB&#39;) from  dual;<br/>
select dbms_metadata.get_granted_ddl(&#39;OBJECT_GRANT&#39;,&#39;SQMDB&#39;) from   dual;<br/>
select dbms_metadata.get_granted_ddl(&#39;ROLE_GRANT&#39;,&#39;SQMDB&#39;) from   dual;<br/>
select dbms_metadata.get_granted_ddl(&#39;SYSTEM_GRANT&#39;,&#39;SQMDB&#39;) from   dual;<br/>
--表空间创建语句<br/>
select dbms_metadata.get_ddl(&#39;TABLESPACE&#39;,&#39;SQMDB&#39;) from dual;<br/>
--全实例的表空间及文件名，把这个结果集记录下来，以后重新建立<br/>
select * FROM SYS.DBA_DATA_FILES</p></li>
<li><p>查看所有代码<br/>
select distinct type from all_source where owner=&#39;SQMDB&#39; –不包含视图</p></li>
<li><p>部分聚合，百分占比<br/>
with dat as( <br/>
select 1 as ci,100 as traffic,23 as user_num from dual union all<br/>
select 1 as ci,100 as traffic,24 as user_num from dual union all<br/>
select 2 as ci,100 as traffic,40 as user_num from dual union all<br/>
select 2 as ci,100 as traffic,60 as user_num from dual union all<br/>
select 3 as ci,100 as traffic,20 as user_num from dual union all<br/>
select 3 as ci,100 as traffic,30 as user_num from dual union all<br/>
select 3 as ci,100 as traffic,50 as user_num from dual <br/>
)<br/>
select ci,user_num,round(ratio_to_report(user_num) over(PARTITION BY ci)<em>100,2),<br/>
round(ratio_to_report(user_num) over()</em>100,2)<br/>
from dat</p></li>
<li><p>escape 转义<br/>
%   零或者多个字符<br/>
_    单一任何字符（下划线）<br/>
\     特殊字符<br/>
select table_name from user_tables  where table_name like &#39;T_BULK_%_6151&#39; escape &#39;\&#39;</p></li>
<li><p>DBlink进行远程联接时可优化，如下<br/>
/<em>+driving_site(a)</em>/可以指定某个表在远程服务器上运行。<br/>
select /<em>+driving_site(a)</em>/ a.sdate,a.imsi,<br/>
sum(case when a.network_type=2 then total_traffic end) as total_traffic_2g,<br/>
sum(case when a.network_type=3 then total_traffic end) as total_traffic_3g,<br/>
sum(case when c.network_type=2 then c.online_time_parallel end) online_time_2g,<br/>
sum(case when c.network_type=3 then c.online_time_parallel end) online_time_3g<br/>
from sqmdb.rpt_KQI_Setup_IMSI@sqmdb_23g a inner join TEMP__0000224667 b on a.imsi=b.imsi<br/>
left join sqmdb.RPT_HTTP_PARALLEL@sqmdb_23g c on a.imsi=c.imsi and a.sdate=c.sdate<br/>
where  a.sdate&gt;= to_date(&#39;2015-04-28 07:00:00&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)<br/>
and a.sdate &lt; to_date(&#39;2015-04-28 12:00:00&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)<br/>
--and a.imsi in(460008243147992,460006641328596)<br/>
group by a.sdate,a.imsi</p></li>
<li><p>materialize  物化视图，有时可优化with dat</p></li>
</ol>

<p>原因找到了，就得想办法把执行计划的FILTER去掉。开始想加HINT，但是实验了很多HINT，都不起作用。最后的结果还一样，后来想到WITH AS 能提高SQL的查询速度，就把影响SQL执行的那段SQL放到WITH AS里面，结果还是一样。后来尝试把HINT MATERIALIZE和WITH AS 结合使用，修改成如下的SQL，查询速度立即提升了很多。</p>

<ol>
<li>WITH PARAMS AS  </li>
<li> (SELECT &#39;&#39; USER_ID, &#39;&#39; SDATE, &#39;%&#39; || &#39;&#39; || &#39;%&#39; SNAME FROM DUAL),  </li>
<li>USERNAMEDATA AS  </li>
<li> (SELECT /<em>+ materialize </em>/  </li>
<li>   AU.USERNAME  </li>
<li>    FROM ALL_USERS AU  </li>
<li><p>在用hit时如果表指定了别名，hit里也要用别名。<br/>
 select/<em>+ parallel(a,4) driving_site(a)</em>/ imsi,CIfrom s1dss2_2015081610 a  <br/>
where succflag=0 group by imsi,CI</p></li>
<li><p>看所有定时任务<br/>
select * from  user_jobs</p></li>
<li><p>建立联合主键<br/>
alter table xxx add constraints xxx_pk primary key (c1,c2,c3,c4,c5....);</p></li>
<li><p>重启oracle实例<br/>
\(  su - oracle<br/>
\)  lsnrctl stop<br/>
\(  sqlplus &quot;/as sysdba&quot;<br/>
SQL&gt;  shutdown immediate; 这一句关闭实例<br/>
SQL&gt;  quit<br/>
\)  lsnrctl start<br/>
$  sqlplus /nolog<br/>
SQL&gt;  connect / as sysdba<br/>
SQL&gt;  startup; 这一句开启实例</p></li>
</ol>

<p>--重启监听<br/>
[oracle@nokia ~]$ lsnrctl start<br/>
--查看有那些实例</p>

<ol>
<li>sqlplus sysdba登陆卡住<br/>
[oracle@ycdecoder1 ~]$ sqlplus -prelim / as sysdba<br/>
SQL*Plus: Release 11.2.0.1.0 Production on Mon Oct 10 16:31:42 2016<br/>
Copyright (c) 1982, 2009, Oracle.  All rights reserved.<br/>
SQL&gt; shutdown abort<br/>
;ORACLE instance shut down.</li>
<li>Clob字段插入数据<br/>
insert into sch_datatable_script values(9999,&#39;zqtest&#39;,empty_clob(),0)</li>
</ol>

<p>DECLARE<br/>
  lobloc CLOB;<br/>
  buffer VARCHAR2(2000);<br/>
  amount NUMBER := 20;<br/>
  offset NUMBER := 1;<br/>
BEGIN<br/>
  --初始化要写入的数据<br/><br/>
  buffer := &#39;This is a writing example&#39;;<br/>
  amount := length(buffer);<br/>
  SELECT script<br/>
    INTO lobloc --   获取定位器并锁定行<br/><br/>
    FROM sch_datatable_script<br/>
   WHERE oid=9999 FOR UPDATE;<br/>
  dbms_lob.writeappend(lobloc,<br/>
                 amount,<br/>
                 buffer);<br/>
  COMMIT;<br/>
END;<br/>
29. 看表和视图的依赖关系<br/>
select * from user_dependencies where referenced_name=upper(&#39;rpt_dev_product_d&#39;)<br/>
30. long 字段查询<br/>
create table zqtest_01 as<br/>
select view_name,TO_LOB(text) as a from user_views</p>

<p>select * from zqtest_01 where a like&#39;%其他%&#39;<br/>
31. 查看历史上耗资源SQL<br/>
select b.username username,a.disk_reads reads,trunc(a.CPU_TIME/1000/60) as cputime,<br/>
    a.executions exec,a.disk_reads/decode(a.executions,0,1,a.executions) rds_exec_ratio,<br/>
    a.sql_text Statement,a.SQL_FULLTEXT,<br/>
    c.MACHINE,c.TERMINAL,c.PROGRAM,c.<br/>
from  v\(sqlarea a,dba_users b,v\)session c<br/>
where a.parsing_user_id=b.user_id<br/>
 and a.disk_reads &gt; 100000<br/>
 and  a.hash_value = c.sql_hash_value(+)<br/>
order by a.disk_reads desc;<br/>
32. 删除用户<br/>
[oracle@ZZLTEDATABASE ~]\( export ORACLE_SID=sqmmt<br/>
[oracle@ZZLTEDATABASE ~]\) echo \(ORACLE_SID<br/>
sqmmt<br/>
[oracle@ZZLTEDATABASE ~]\) sqlplus / as sysdba<br/>
SQL&gt; drop user bcdb_v2 cascade;</p>

<ol>
<li>手动锁表<br/>
lock table tablename in exclusive mode<br/>
这个表示手动锁表tablename<br/>
其他的事物只能读，不能写，如果你要写数据只能等待该过程执行完成，否则阻塞所有要修改操作会话。<br/>
可以这么说编上面过程除非特殊情况需要这样，真正的应用系统不会这么干。 这样应用只会使你的事物串行执行，对于并发系统这就是自寻死路</li>
<li><p>redo log相关操作<br/>
--查看redo log 切换频率<br/>
select sequence#,first_time,nexttime,round(((first_time-nexttime)<em>24)</em>60,2) diff <br/>
from (<br/>
select sequence#,first_time, lag(first_time) over(order by sequence#) nexttime<br/>
from v\(log_history <br/>
where thread#=1<br/>
) order by sequence# desc<br/>
--查看文件地址<br/>
SELECT dbn.name &quot;DB_Name&quot; ,logf.group#, logf.status, logf.MEMBER<br/>
FROM v\)logfile logf,v\(database dbn;<br/>
查看文件大小<br/>
SELECT dbn.name &quot;DB_Name&quot; ,log1.group#, log1.thread#, log1.sequence#, log1.BYTES/1024/1024 &quot;SIZE(MB)&quot;, log1.members, log1.archived, log1.status,<br/>
   to_char(log1.first_change#) &quot;FIRST_CHANGE#&quot;, log1.first_time<br/>
FROM v\)log log1,v$database dbn;</p></li>
<li><p>列拼接</p></li>
</ol>

<p>select table_name,listagg(lower(column_name),&#39;,&#39;) within GROUP (order by table_name) from user_tab_cols where lower(table_name) =&#39;cfg_cell_rule_v3&#39;<br/>
group by table_name<br/>
with temp as(<br/>
  select &#39;China&#39; nation ,&#39;Guangzhou&#39; city from dual union all<br/>
  select &#39;China&#39; nation ,&#39;Shanghai&#39; city from dual union all<br/>
  select &#39;China&#39; nation ,&#39;Beijing&#39; city from dual union all<br/>
  select &#39;USA&#39; nation ,&#39;New York&#39; city from dual union all<br/>
  select &#39;USA&#39; nation ,&#39;Bostom&#39; city from dual union all<br/>
  select &#39;Japan&#39; nation ,&#39;Tokyo&#39; city from dual <br/>
)<br/>
select nation,listagg(city,&#39;,&#39;) within GROUP (order by city)<br/>
from temp<br/>
group by nation</p>

<p>with temp as(<br/>
  select 500 population, &#39;China&#39; nation ,&#39;Guangzhou&#39; city from dual union all<br/>
  select 1500 population, &#39;China&#39; nation ,&#39;Shanghai&#39; city from dual union all<br/>
  select 500 population, &#39;China&#39; nation ,&#39;Beijing&#39; city from dual union all<br/>
  select 1000 population, &#39;USA&#39; nation ,&#39;New York&#39; city from dual union all<br/>
  select 500 population, &#39;USA&#39; nation ,&#39;Bostom&#39; city from dual union all<br/>
  select 500 population, &#39;Japan&#39; nation ,&#39;Tokyo&#39; city from dual <br/>
)<br/>
select population,<br/>
       nation,<br/>
       city,<br/>
       listagg(city,&#39;,&#39;) within GROUP (order by city) over (partition by nation) rank<br/>
from temp</p>

<p>with temp as(<br/><br/>
  select &#39;China&#39; nation ,&#39;Guangzhou&#39; city from dual union all<br/><br/>
  select &#39;China&#39; nation ,&#39;Shanghai&#39; city from dual union all<br/><br/>
  select &#39;China&#39; nation ,&#39;Beijing&#39; city from dual union all<br/><br/>
  select &#39;USA&#39; nation ,&#39;New York&#39; city from dual union all<br/><br/>
  select &#39;USA&#39; nation ,&#39;Bostom&#39; city from dual union all<br/><br/>
  select &#39;Japan&#39; nation ,&#39;Tokyo&#39; city from dual<br/><br/>
)<br/><br/>
select nation,wmsys.wm_concat(city)<br/>
from temp<br/><br/>
group by nation;</p>

<ol>
<li>列转行pivot，行转列unpivot<br/>
with dat as (<br/>
select  1 as id, &#39;苹果&#39; as name, 1000 as  nums from dual union all<br/>
select  2,&#39;苹果&#39;,2000 from dual union all<br/>
select  3,&#39;苹果&#39;,4000 from dual union all<br/>
select  4,&#39;橘子&#39;,5000 from dual union all<br/>
select 5,&#39;橘子&#39;,3000 from dual union all<br/>
select  6,&#39;葡萄&#39;,3500 from dual union all<br/>
select  7,&#39;芒果&#39;,4200 from dual union all<br/>
select  8,&#39;芒果&#39;,5500 from dual union all<br/>
)select * from dat</li>
</ol>

<p>select 5,&#39;一&#39;,3000 from dual<br/>
37. 列拼接成一行SYS_CONNECT_BY_PATH<br/>
38. 移动重命名文件</p>

<p>例如，我需要将/u01/app/oracle/oradata/GSP/temp4.dbf这个文件重命名为/u01/app/oracle/oradata/GSP/temp04.dbf</p>

<p>1: 将临时表空间的临时文件脱机</p>

<p>ALTER DATABASE TEMPFILE  &#39;/data3/sqmmt/sqmdb_temp.dbf&#39; OFFLINE;<br/>
2：移动或重命名相关的临时文件<br/>
mv /data3/sqmmt/sqmdb_temp.dbf /data2/sqmmt/sqmdb_temp.dbf<br/>
3: 使用脚本ALTER DATABASE RENAME FILE<br/>
ALTER DATABASE RENAME FILE   &#39;/data3/sqmmt/sqmdb_temp.dbf&#39; TO &#39;/data2/sqmmt/sqmdb_temp.dbf&#39;;<br/>
4: 将临时表空间的临时文件联机<br/>
ALTER DATABASE TEMPFILE &#39;/data2/sqmmt/sqmdb_temp.dbf&#39; ONLINE;<br/>
39. 关闭dblink<br/>
  最近出现一个关于db-link session的问题，在A数据库建立了一个DBLINK，其他有三台服务器利用DBLINK连接到A数据库，但是在应用中利用了连接池进行<br/>
session管理，当使用DBLINK时，在A数据库出现session快速增长，达到了顶峰从而导致进程资源消耗连接出现中断。<br/>
commit;<br/>
  execute immediate &#39;alter session close database link test&#39;;--test为dblink名<br/>
40. MINUS(减去),INTERSECT(交集)和UNION ALL(并集);<br/>
41. 临时表空间超大处理<br/>
select sess.SID, segtype, blocks * 8 / 1000 &quot;MB&quot;, sql_text<br/>
  from v\(sort_usage sort, v\)session sess, v$sql sql<br/>
 where sort.SESSION_ADDR = sess.SADDR<br/>
   and sql.ADDRESS = sess.SQL_ADDRESS<br/>
 order by blocks desc;</p>

<p>SELECT username,default_tablespace,temporary_tablespace FROM DBA_USERS;</p>

<p>SELECT FILE#                        AS FILE_NUMBER<br/>
    ,NAME                           AS NAME<br/>
    ,CREATION_TIME                  AS CREATION_TIME<br/>
    ,BLOCK_SIZE                     AS BLOCK_SIZE<br/>
    ,BYTES/1024/1024/1024           AS &quot;FILE_SIZE(G)&quot;<br/>
    ,CREATE_BYTES/1024/1024/1024    AS &quot;INIT_SIZE(G)&quot;<br/>
    ,STATUS                         AS STATUS<br/>
    ,ENABLED                        AS ENABLED<br/>
FROM V$TEMPFILE;</p>

<p>SELECT PROPERTY_NAME, PROPERTY_VALUE<br/>
 FROM DATABASE_PROPERTIES<br/>
WHERE PROPERTY_NAME=&#39;DEFAULT_TEMP_TABLESPACE&#39;</p>

<p>create   temporary   tablespace   sqmdb_temp01   TEMPFILE   &#39;/data2/sqmmt/sqmdb_temp01.dbf &#39;   SIZE   8192M<br/><br/>
REUSE   AUTOEXTEND   ON   NEXT  1024K   MAXSIZE   UNLIMITED;   --创建中转临时表空间 <br/>
ALTER DATABASE TEMPFILE  &#39;/data2/sqmmt/sqmdb_temp.dbf&#39; OFFLINE;<br/>
alter   database   default   temporary   tablespace   sqmdb_temp01;    --改变缺省临时表空间<br/>
drop   tablespace   sqmdb_temp   including   contents   and   datafiles;  --删除原来临时表空间<br/>
CREATE BIGFILE TEMPORARY TABLESPACE SQMDB_TEMP TEMPFILE <br/>
  &#39;/opt/oradata01/sqmmt/sqmdb_temp.dbf&#39; SIZE 1G AUTOEXTEND ON NEXT 50M MAXSIZE 5359738344K<br/>
TABLESPACE GROUP &#39;&#39;<br/>
EXTENT MANAGEMENT LOCAL UNIFORM SIZE 1M;<br/>
alter   database   default   temporary   tablespace   sqmdb_temp;  </p>

<ol>
<li>Function 返回表<br/>
--声明类型<br/>
CREATE OR REPLACE TYPE &quot;IMSIMSISDN_TABLE2&quot; as object<br/>
(<br/>
imsi   varchar2(50),<br/>
msisdn varchar2(50),<br/>
IMEI VARCHAR2(20),<br/>
MS_BRAND_product VARCHAR2(355),<br/>
VOLTE_UA  VARCHAR2(256),<br/>
user_type         varchar2(1)<br/>
);<br/>
--声明表类型<br/>
CREATE OR REPLACE TYPE &quot;T_TABLE2&quot; is table of imsimsisdn_table2;</li>
</ol>

<p>CREATE OR REPLACE FUNCTION getimsiandmsisdn_volte_exp<br/>
(<br/>
    i_instr         varchar2,<br/>
    i_strtype       integer<br/>
)<br/>
RETURN t_table2 pipelined AS<br/>
    v_imsimsisn_table imsimsisdn_table2;<br/>
BEGIN<br/>
v_imsimsisn_table := imsimsisdn_table2(v_imsi,v_msisdn,v_imei,v_ms_brand_product,v_volte_ua,v_user_type3);<br/>
                    pipe row(v_imsimsisn_table);<br/>
END;</p>

<p>select * from table(getimsiandmsisdn_volte_exp(&#39;460029511154402,460027574310114&#39;,0));</p>

<p>自己百度<br/>
--<a href="http://blog.chinaunix.net/uid-17240229-id-311309.html">http://blog.chinaunix.net/uid-17240229-id-311309.html</a><br/>
朋友的一数据库redo log 日志太小，导致日志切换很频繁。<br/>
 1.查看当前日志组成员</p>

<ol>
<li><p>SQL&gt; select member from v$logfile; </p></li>
<li></li>
<li><p>MEMBER</p></li>
</ol>

<hr/>

<ol>
<li>/u01/oracle/oradata/orcl/redo03.log</li>
<li>/u01/oracle/oradata/orcl/redo02.log</li>
<li>/u01/oracle/oradata/orcl/redo01.log<br/>
2. 查看当前日志组状态：</li>
<li><p>SQL&gt; select group#,members,bytes/1024/1024,status from v$log; </p></li>
<li></li>
<li><p>    GROUP# MEMBERS BYTES/1024/1024 STATUS</p></li>
<li><hr/></li>
<li><p>         1 1 50 ACTIVE</p></li>
<li><p>         2 1 50 CURRENT</p></li>
<li><p>         3 1 50 INACTIVE<br/>
现在有三个日志成员，大小为50M，欲更改为100M<br/>
增加日志组</p></li>
<li><p>SQL&gt;alter database add logfile group 4 (&#39;/u01/oracle/oradata/orcl/redo04.log&#39;) size 100M;</p></li>
<li><p>SQL&gt;alter database add logfile group 5 (&#39;/u01/oracle/oradata/orcl/redo05.log&#39;) size 100M;</p></li>
<li><p>SQL&gt;alter database add logfile group 6 (&#39;/u01/oracle/oradata/orcl/redo06.log&#39;) size 100M;<br/>
3.切换到新增的日志组上</p></li>
<li><p>SQL&gt; alter system switch logfile;</p></li>
<li></li>
<li><p>System altered.</p></li>
<li></li>
<li><p>SQL&gt; alter system switch logfile;</p></li>
<li></li>
<li><p>System altered.</p></li>
<li><p>SQL&gt; select group#,members,bytes/1024/1024,status from v$log</p></li>
<li></li>
<li><p>    GROUP#    MEMBERS BYTES/1024/1024 STATUS</p></li>
<li><hr/></li>
<li><p>         1          1              50 INACTIVE</p></li>
<li><p>         2          1              50 INACTIVE</p></li>
<li><p>         3          1              50 ACTIVE</p></li>
<li><p>         4          1             100 CURRENT</p></li>
<li><p>         5          1             100 UNUSED</p></li>
<li><p>         6          1             100 UNUSED</p></li>
<li></li>
</ol>

<p>a. CURRENT指当前的日志文件，在进行实例恢复时是必须的；<br/>
b. ACTIVE是指活动的非当前日志，在进行实例恢复时会被用到。Active状态意味着，Checkpoint尚未完成，因此该日志文件不能被覆盖。<br/>
c. INACTIVE是非活动日志，在实例恢复时不再需要，但在介质恢复时可能需要。<br/>
d. UNUSED表示该日志从未被写入，可能是刚添加的，或RESETLOGS后被重置。</p>

<p>4.删除旧的日志组</p>

<ol>
<li><p>SQL&gt; alter database drop logfile group 1; </p></li>
<li></li>
<li><p>Database altered.</p></li>
<li></li>
<li><p>SQL&gt; alter database drop logfile group 2</p></li>
<li><p>  2 /</p></li>
<li></li>
<li><p>Database altered.</p></li>
<li></li>
<li><p>SQL&gt; alter database drop logfile group 3;</p></li>
<li><p>alter database drop logfile group 3</p></li>
<li><p>*</p></li>
<li><p>ERROR at line 1:</p></li>
<li><p>ORA-01624: log 3 needed for crash recovery of instance dbserver (thread 1)</p></li>
<li><p>ORA-00312: online log 3 thread 1: &#39;/u01/oracle/oradata/orcl/redo03.log&#39;<br/>
由于log 3 日志成员还出去active 状态，所以不能drop掉的，再次执行 alter system switch logfile; </p></li>
<li><p>SQL&gt; select group#,members,bytes/1024/1024,status from v$log;</p></li>
<li></li>
<li><p>    GROUP# MEMBERS BYTES/1024/1024 STATUS</p></li>
<li><hr/></li>
<li><p>         3 1 50 INACTIVE</p></li>
<li><p>         4 1 100 ACTIVE</p></li>
<li><p>         5 1 100 CURRENT</p></li>
<li><p>         6 1 100 UNUSED</p></li>
<li><p>SQL&gt; alter database drop logfile group 3;</p></li>
<li></li>
<li><p>Database altered.</p></li>
<li></li>
<li></li>
<li><p>SQL&gt; select group#,members,bytes/1024/1024,status from v$log;</p></li>
<li></li>
<li><p>    GROUP# MEMBERS BYTES/1024/1024 STATUS</p></li>
<li><hr/></li>
<li><p>         4 1 100 ACTIVE</p></li>
<li><p>         5 1 100 ACTIVE</p></li>
<li><p>         6 1 100 CURRENT<br/>
在操作系统下删除掉redolog 日志文件<br/>
mv  /u01/oracle/oradata/orcl/redo0[1-3].log /tmp</p></li>
</ol>

<p><a href="http://www.2cto.com/database/201311/254441.html">http://www.2cto.com/database/201311/254441.html</a><br/>
<a href="http://www.cnblogs.com/chuncn/archive/2009/04/29/1381282.html">http://www.cnblogs.com/chuncn/archive/2009/04/29/1381282.html</a><br/>
oracle安装教程:<a href="http://www.itpux.com/thread-81-1-1.html">http://www.itpux.com/thread-81-1-1.html</a></p>

<p>1、Oracle 12c RAC安装配置详细记录过程_图文并茂_v1.0.pdf<br/>
下载地址：<a href="http://www.itpux.com/thread-1834-1-1.html">http://www.itpux.com/thread-1834-1-1.html</a></p>

<p>2、Oracle 11g R2 RAC 安装配置详细记录过程_图文并茂_v2.0.pdf<br/>
下载地址：<a href="http://www.itpux.com/thread-81-1-1.html">http://www.itpux.com/thread-81-1-1.html</a><br/>
14.处理月份天数不定的办法      <br/>
   select to_char(add_months(last_day(sysdate) +1, -2), &#39;yyyymmdd&#39;),last_day(sysdate) from dual    <br/>
16.找出今年的天数      <br/>
   select add_months(trunc(sysdate,&#39;year&#39;), 12) - trunc(sysdate,&#39;year&#39;) from dual    <br/>
   闰年的处理方法      <br/>
   to_char( last_day( to_date(&#39;02&#39;    | | :year,&#39;mmyyyy&#39;) ), &#39;dd&#39; )      <br/>
   如果是28就不是闰年    <br/>
17.yyyy与rrrr的区别      <br/>
   &#39;YYYY99 TO_C      <br/>
   ------- ----      <br/>
   yyyy 99 0099      <br/>
   rrrr 99 1999      <br/>
   yyyy 01 0001      <br/>
   rrrr 01 2001    <br/>
18.不同时区的处理      <br/>
   select to_char( NEW_TIME( sysdate, &#39;GMT&#39;,&#39;EST&#39;), &#39;dd/mm/yyyy hh:mi:ss&#39;) ,sysdate      <br/>
   from dual;    <br/>
19.5秒钟一个间隔      <br/>
   Select TO_DATE(FLOOR(TO_CHAR(sysdate,&#39;SSSSS&#39;)/300) * 300,&#39;SSSSS&#39;) ,TO_CHAR(sysdate,&#39;SSSSS&#39;)      <br/>
   from dual    <br/>
   2002-11-1 9:55:00 35786      <br/>
   SSSSS表示5位秒数    <br/>
20.一年的第几天      <br/>
   select TO_CHAR(SYSDATE,&#39;DDD&#39;),sysdate from dual<br/>
        <br/>
   310 2002-11-6 10:03:51    <br/>
21.计算小时,分,秒,毫秒      <br/>
    select      <br/>
     Days,      <br/>
     A,      <br/>
     TRUNC(A<em>24) Hours,      <br/>
     TRUNC(A</em>24<em>60 - 60</em>TRUNC(A<em>24)) Minutes,      <br/>
     TRUNC(A</em>24<em>60</em>60 - 60<em>TRUNC(A</em>24<em>60)) Seconds,      <br/>
     TRUNC(A</em>24<em>60</em>60<em>100 - 100</em>TRUNC(A<em>24</em>60*60)) mSeconds      <br/>
    from      <br/>
    (      <br/>
     select      <br/>
     trunc(sysdate) Days,      <br/>
     sysdate - trunc(sysdate) A      <br/>
     from dual      <br/>
   )    </p>

<p>   select * from tabname      <br/>
   order by decode(mode,&#39;FIFO&#39;,1,-1)<em>to_char(rq,&#39;yyyymmddhh24miss&#39;);      <br/>
   <br/>
   //      <br/>
   floor((date2-date1) /365) 作为年      <br/>
   floor((date2-date1, 365) /30) 作为月      <br/>
   d(mod(date2-date1, 365), 30)作为日.<br/>
23.next_day函数      返回下个星期的日期,day为1-7或星期日-星期六,1表示星期日<br/>
   next_day(sysdate,6)是从当前开始下一个星期五。后面的数字是从星期日开始算起。      <br/>
   1 2 3 4 5 6 7      <br/>
   日 一 二 三 四 五 六    <br/>
   <br/>
   --------------------------------------------------------------- <br/>
   <br/>
   select    (sysdate-to_date(&#39;2003-12-03 12:55:45&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;))</em>24<em>60</em>60 from ddual<br/>
   日期 返回的是天 然后 转换为ss<br/>
     <br/>
24,round<a href="day:%E8%88%8D%E5%85%A5%E5%88%B0%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E6%98%9F%E6%9C%9F%E6%97%A5">舍入到最接近的日期</a><br/>
   select sysdate S1,<br/>
   round(sysdate) S2 ,<br/>
   round(sysdate,&#39;year&#39;) YEAR,<br/>
   round(sysdate,&#39;month&#39;) MONTH ,<br/>
   round(sysdate,&#39;day&#39;) DAY from dual<br/>
25,trunc[截断到最接近的日期,单位为天] ,返回的是日期类型<br/>
   select sysdate S1,                     <br/>
     trunc(sysdate) S2,                 //返回当前日期,无时分秒<br/>
     trunc(sysdate,&#39;year&#39;) YEAR,        //返回当前年的1月1日,无时分秒<br/>
     trunc(sysdate,&#39;month&#39;) MONTH ,     //返回当前月的1日,无时分秒<br/>
     trunc(sysdate,&#39;day&#39;) DAY           //返回当前星期的星期天,无时分秒<br/>
   from dual<br/>
26,返回日期列表中最晚日期<br/>
   select greatest(&#39;01-1月-04&#39;,&#39;04-1月-04&#39;,&#39;10-2月-04&#39;) from dual<br/>
27.计算时间差<br/>
     注:oracle时间差是以天数为单位,所以换算成年月,日<br/>
     <br/>
      select floor(to_number(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;))/365) as spanYears from dual        //时间差-年<br/>
      select ceil(moths_between(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;))) as spanMonths from dual        //时间差-月<br/>
      select floor(to_number(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;))) as spanDays from dual             //时间差-天<br/>
      select floor(to_number(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;))<em>24) as spanHours from dual         //时间差-时<br/>
      select floor(to_number(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;))</em>24<em>60) as spanMinutes from dual    //时间差-分<br/>
      select floor(to_number(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;))</em>24<em>60</em>60) as spanSeconds from dual //时间差-秒<br/>
28.更新时间<br/>
     注:oracle时间加减是以天数为单位,设改变量为n,所以换算成年月,日<br/>
     select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),to_char(sysdate+n*365,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual        //改变时间-年<br/>
     select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),add_months(sysdate,n) as newTime from dual                                 //改变时间-月<br/>
     select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),to_char(sysdate+n,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual            //改变时间-日<br/>
     select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),to_char(sysdate+n/24,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual         //改变时间-时<br/>
     select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),to_char(sysdate+n/24/60,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual      //改变时间-分<br/>
     select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),to_char(sysdate+n/24/60/60,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual   //改变时间-秒<br/>
29.查找月的第一天,最后一天<br/>
     SELECT Trunc(Trunc(SYSDATE, &#39;MONTH&#39;) - 1, &#39;MONTH&#39;) First_Day_Last_Month,<br/>
       Trunc(SYSDATE, &#39;MONTH&#39;) - 1 / 86400 Last_Day_Last_Month,<br/>
       Trunc(SYSDATE, &#39;MONTH&#39;) First_Day_Cur_Month,<br/>
       LAST_DAY(Trunc(SYSDATE, &#39;MONTH&#39;)) + 1 - 1 / 86400 Last_Day_Cur_Month<br/>
   FROM dual;</p>

<p>三. 字符函数(可用于字面字符或数据库列)<br/>
1，字符串截取<br/>
   select substr(&#39;abcdef&#39;,1,3) from dual<br/>
2,查找子串位置<br/>
   select instr(&#39;abcfdgfdhd&#39;,&#39;fd&#39;) from dual<br/>
3,字符串连接<br/>
   select &#39;HELLO&#39;||&#39;hello world&#39; from dual;<br/>
4, 1)去掉字符串中的空格<br/>
    select ltrim(&#39; abc&#39;) s1,<br/>
    rtrim(&#39;zhang &#39;) s2,<br/>
    trim(&#39; zhang &#39;) s3 from dual<br/>
   2)去掉前导和后缀<br/>
    select trim(leading 9 from 9998767999) s1,<br/>
    trim(trailing 9 from 9998767999) s2,<br/>
    trim(9 from 9998767999) s3 from dual;<br/>
   <br/>
5,返回字符串首字母的Ascii值<br/>
   select ascii(&#39;a&#39;) from dual<br/>
6,返回ascii值对应的字母<br/>
   select chr(97) from dual<br/>
7,计算字符串长度 <br/>
   select length(&#39;abcdef&#39;) from dual<br/>
8,initcap（首字母变大写） ,lower(变小写),upper(变大写)<br/>
   select lower(&#39;ABC&#39;) s1, <br/>
       upper(&#39;def&#39;) s2, <br/>
       initcap(&#39;efg&#39;) s3<br/>
   from dual;<br/>
9,Replace<br/>
   select replace(&#39;abc&#39;,&#39;b&#39;,&#39;xy&#39;) from dual;<br/>
10,translate<br/>
   select translate(&#39;abc&#39;,&#39;b&#39;,&#39;xx&#39;) from dual; -- x是1位<br/>
11,lpad [左添充] rpad <a href="%E7%94%A8%E4%BA%8E%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F">右填充</a><br/>
   select lpad(&#39;func&#39;,15,&#39;=&#39;) s1, rpad(&#39;func&#39;,15,&#39;-&#39;) s2 from dual;<br/>
   select lpad(dname,14,&#39;=&#39;) from dept;<br/>
12, decode[实现if ..then 逻辑]   注:第一个是表达式,最后一个是不满足任何一个条件的值<br/>
   select deptno,decode(deptno,10,&#39;1&#39;,20,&#39;2&#39;,30,&#39;3&#39;,&#39;其他&#39;) from dept;<br/>
   例:<br/>
   select seed,account_name,decode(seed,111,1000,200,2000,0) from t_userInfo//如果seed为111,则取1000;为200,取2000;其它取0<br/>
   select seed,account_name,decode(sign(seed-111),1,&#39;big seed&#39;,-1,&#39;little seed&#39;,&#39;equal seed&#39;) from t_userInfo//如果seed&gt;111,则显示大;为200,则显示小;其它则显<br/>
示相等<br/>
13 case[实现switch ..case 逻辑]<br/>
    SELECT CASE X-FIELD <br/>
         WHEN X-FIELD &lt; 40 THEN &#39;X-FIELD 小于 40&#39;<br/>
         WHEN X-FIELD &lt; 50 THEN &#39;X-FIELD 小于 50&#39;<br/>
         WHEN X-FIELD &lt; 60 THEN &#39;X-FIELD 小于 60&#39;<br/>
         ELSE &#39;UNBEKNOWN&#39;<br/>
        END<br/>
   FROM DUAL <br/>
   <br/>
   注:CASE语句在处理类似问题就显得非常灵活。当只是需要匹配少量数值时，用Decode更为简洁。<br/>
四.数字函数<br/>
1，取整函数（ceil 向上取整,floor 向下取整）<br/>
   select ceil(66.6) N1,floor(66.6) N2 from dual;<br/>
2, 取幂(power) 和 求平方根(sqrt)<br/>
   select power(3,2) N1,sqrt(9) N2 from dual;<br/>
3,求余<br/>
   select mod(9,5) from dual;<br/>
4,返回固定小数位数 (round:四舍五入，trunc:直接截断)<br/>
   select round(66.667,2) N1,trunc(66.667,2) N2 from dual;<br/>
5,返回值的符号(正数返回为1,负数为-1)<br/>
   select sign(-32),sign(293) from dual;<br/>
五.转换函数<br/>
1，to_char()[将日期和数字类型转换成字符类型]<br/>
   1) select to_char(sysdate) s1,<br/>
        to_char(sysdate,&#39;yyyy-mm-dd&#39;) s2,<br/>
        to_char(sysdate,&#39;yyyy&#39;) s3,<br/>
        to_char(sysdate,&#39;yyyy-mm-dd hh12:mi:ss&#39;) s4,<br/>
        to_char(sysdate, &#39;hh24:mi:ss&#39;) s5,<br/>
        to_char(sysdate,&#39;DAY&#39;) s6 <br/>
    from dual;<br/>
   2) select sal,to_char(sal,&#39;＄99999&#39;) n1,to_char(sal,&#39;＄99,999&#39;) n2 from emp<br/>
2, to_date()[将字符类型转换为日期类型] <br/>
    insert into emp(empno,hiredate) values(8000,to_date(&#39;2004-10-10&#39;,&#39;yyyy-mm-dd&#39;));<br/>
   <br/>
3, to_number() 转换为数字类型 <br/>
    select to_number(to_char(sysdate,&#39;hh12&#39;)) from dual; //以数字显示的小时数<br/>
   <br/>
六.其他函数<br/>
   1.user: <br/>
    返回登录的用户名称 <br/>
    select user from dual;<br/>
    <br/>
   2.vsize: <br/>
    返回表达式所需的字节数<br/>
    select vsize(&#39;HELLO&#39;) from dual;<br/>
   <br/>
   3.nvl(ex1,ex2): 　<br/>
    ex1值为空则返回ex2,否则返回该值本身ex1（常用） <br/>
    例：如果雇员没有佣金，将显示0，否则显示佣金 <br/>
    select comm,nvl(comm,0) from emp;<br/>
   <br/>
   4.nullif(ex1,ex2): <br/>
    值相等返空，否则返回第一个值<br/>
    例：如果工资和佣金相等，则显示空，否则显示工资<br/>
    select nullif(sal,comm),sal,comm from emp;<br/>
   <br/>
   5.coalesce: 　<br/>
    返回列表中第一个非空表达式<br/>
    select comm,sal,coalesce(comm,sal,sal<em>10) from emp;<br/>
   <br/>
   6.nvl2(ex1,ex2,ex3) :<br/>
    如果ex1不为空，显示ex2,否则显示ex3<br/>
    如：查看有佣金的雇员姓名以及他们的佣金 <br/>
    　　select nvl2(comm,ename,&#39;) as HaveCommName,comm from emp;<br/>
   <br/>
   <br/>
七.分组函数<br/>
max min avg count sum<br/>
1，整个结果集是一个组<br/>
   1) 求部门30 的最高工资，最低工资,平均工资，总人数，有工作的人数，工种数量及工资总和<br/>
     select max(ename),max(sal), <br/>
     min(ename),min(sal),<br/>
     avg(sal),<br/>
     count(</em>) ,count(job),count(distinct(job)) ,<br/>
     sum(sal) from emp where deptno=30;<br/>
2, 带group by 和 having 的分组<br/>
   1)按部门分组求最高工资，最低工资，总人数，有工作的人数，工种数量及工资总和<br/>
    select deptno, max(ename),max(sal),<br/>
    min(ename),min(sal),<br/>
    avg(sal),<br/>
    count(<em>) ,count(job),count(distinct(job)) ,<br/>
    sum(sal) from emp group by deptno;<br/>
   <br/>
   2)部门30的最高工资，最低工资，总人数，有工作的人数，工种数量及工资总和 <br/>
    select deptno, max(ename),max(sal),<br/>
    min(ename),min(sal),<br/>
    avg(sal),<br/>
    count(</em>) ,count(job),count(distinct(job)) ,<br/>
    sum(sal) from emp group by deptno having deptno=30;<br/>
   <br/>
3, stddev 返回一组值的标准偏差<br/>
    select deptno,stddev(sal) from emp group by deptno;<br/>
    variance 返回一组值的方差差<br/>
    select deptno,variance(sal) from emp group by deptno;<br/>
4, 带有rollup和cube操作符的Group By<br/>
    rollup 按分组的第一个列进行统计和最后的小计<br/>
    cube 按分组的所有列的进行统计和最后的小计<br/>
    select deptno,job ,sum(sal) from emp group by deptno,job;<br/>
    select deptno,job ,sum(sal) from emp group by rollup(deptno,job); <br/>
    cube 产生组内所有列的统计和最后的小计<br/>
    select deptno,job ,sum(sal) from emp group by cube(deptno,job);<br/>
八、临时表<br/>
   只在会话期间或在事务处理期间存在的表.<br/>
   临时表在插入数据时，动态分配空间 <br/>
   create global temporary table temp_dept<br/>
   (dno number,<br/>
   dname varchar2(10))<br/>
   on commit delete rows;<br/>
   insert into temp_dept values(10,&#39;ABC&#39;);<br/>
   commit;<br/>
   select * from temp_dept; --无数据显示,数据自动清除<br/>
   on commit preserve rows:在会话期间表一直可以存在（保留数据）<br/>
   on commit delete rows:事务结束清除数据（在事务结束时自动删除表的数据）</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle查看和修改session数]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640746.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640746.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">切换oracle用户</h2>

<pre class="line-numbers"><code class="language-bash">[root@tbxoracle oracle]# su - oracle
[oracle@tbxoracle ~]$ echo $ORACLE_SID
daily
</code></pre>

<p>确认实例正常，接下来连接sqlplus</p>

<pre class="line-numbers"><code class="language-sql">[oracle@tbxoracle ~]$ sqlplus / as sysdba

SQL*Plus: Release 11.2.0.4.0 Production on Thu Apr 13 15:10:19 2017

Copyright (c) 1982, 2013, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">查看processes和sessions参数</h2>

<pre class="line-numbers"><code class="language-sql">
SQL&gt; show parameter process

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
aq_tm_processes                      integer     1
cell_offload_processing              boolean     TRUE
db_writer_processes                  integer     6
gcs_server_processes                 integer     0
global_txn_processes                 integer     1
job_queue_processes                  integer     1000
log_archive_max_processes            integer     4
processes                            integer     1500
processor_group_name                 string
</code></pre>

<pre class="line-numbers"><code class="language-sql">SQL&gt; show parameter sessions

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
java_max_sessionspace_size           integer     0
java_soft_sessionspace_limit         integer     0
license_max_sessions                 integer     0
license_sessions_warning             integer     0
sessions                             integer     2304
shared_server_sessions               integer
SQL&gt; 
</code></pre>

<p>可以看到<code>processes</code>数为1500，<code>sessions</code>数为2304</p>

<h2 id="toc_2">修改processes和sessions值</h2>

<pre class="line-numbers"><code class="language-sql">SQL&gt; alter system set processes=1600 scope=spfile;

System altered.

SQL&gt; alter system set sessions=2400 scope=spfile;

System altered.
</code></pre>

<blockquote>
<p>修改processes和sessions必须重启Oracle才能生效</p>
</blockquote>

<h2 id="toc_3">ORACLE中连接<code>connection</code>，会话<code>sessions</code>和进程数<code>process</code>的关系</h2>

<p>每个sqllogin称为一个连接（connection),而每个连接，可以产生一个或多个会话，如果数据库运行在专用服务器方式，一个会话对应一个服务器进程（process),如果数据库运行在共享服务器方式，一个服务器进程可以为多个会话服务。 </p>

<h2 id="toc_4">oracle中<strong>系统</strong>process和session的关系</h2>

<p>在SharedServer中的Process 和Oracle 中的Session不是一一对应的，Shared Server中的Process 一个对应着Oracle 中的一个或者一个以上的Session。<br/>
数据库的session和操作系统process是对应的 <br/>
即表示一个session对应一个process，但是一个process未必对应一个session</p>

<ul>
<li>查询数据库当前进程的连接数：</li>
</ul>

<pre class="line-numbers"><code class="language-sql">SQL&gt; select count(*) from v$process;

  COUNT(*)
----------
        41
</code></pre>

<ul>
<li>查看数据库当前会话的连接数：</li>
</ul>

<pre class="line-numbers"><code class="language-sql">SQL&gt; select count(*) from v$session;

  COUNT(*)
----------
        38
</code></pre>

<ul>
<li>查看数据库的并发连接数：</li>
</ul>

<pre class="line-numbers"><code class="language-sql">SQL&gt; select count(*) from v$session where status=&#39;ACTIVE&#39;;

  COUNT(*)
----------
        31
</code></pre>

<ul>
<li>查看当前数据库建立的会话情况：</li>
</ul>

<pre class="line-numbers"><code class="language-sql">
SQL&gt; select sid,serial#,username,program,machine,status from v$session;
       
       SID    SERIAL# USERNAME
---------- ---------- ------------------------------
PROGRAM
------------------------------------------------
MACHINE                                                          STATUS
---------------------------------------------------------------- --------

      1777      35669 DAILY
Toad.exe
WORKGROUP\LIANXI-PC                                              INACTIVE


38 rows selected.
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle缩小表空间方法]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640780.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640780.html</id>
    <content type="html">
<![CDATA[<h3 id="toc_0">1. 查看所有表空间和对应的存储文件信息</h3>

<p><code>select tablespace_name,file_name,online_status from dba_data_files</code></p>

<h3 id="toc_1">2.  查看表空间总大小及空闲空间大小</h3>

<pre class="line-numbers"><code class="language-sql">SELECT df.tablespace_name,df.sum_df_m 
as space_m,fs.sum_fs_m free_space,
to_char(trunc((df.sum_df_m-fs.sum_fs_m)/df.sum_df_m,2)*100) as &quot;used_%&quot;  
from
(select tablespace_name,sum(bytes/1024/1024) as sum_df_m 
from dba_data_files 
group by tablespace_name) df, 
(select tablespace_name,sum(bytes/1024/1024) as sum_fs_m 
from dba_free_space 
group by tablespace_name) fs 
where df.tablespace_name=fs.tablespace_name and
df.tablespace_name=&#39;DAILY&#39;; 
</code></pre>

<span id="more"></span><!-- more -->

<p>只需要修改最后一句中的DAILY为需要查询的表空间名 通过计算空闲百分比可以得出整理空间后，再resize表空间可以将表空间缩小到多大。 如果空闲很低，可以通过以下语句查询是否回收站有大量数据 </p>

<p><code>select * from user_recyclebin</code> <code>select count(*) from user_recyclebin</code> </p>

<p>使用如下语句清空回收站 <code>purge recyclebin;</code> 如果回收站没有数据可以查询是否有太多的历史表没有删除成功</p>

<pre class="line-numbers"><code class="language-sql">select table_name 
from user_tables 
where tablespace_name = &#39;DAILY&#39;  
and table_name like &#39;%&#39;||20160530||&#39;%&#39;;
</code></pre>

<p>如果有删除无用的历史表  </p>

<pre class="line-numbers"><code class="language-sql">declare   
l_sql CLOB;   
CURSOR P_Cursor is     
SELECT &#39;DROP TABLE &#39; || table_name || &#39; purge&#39;       
FROM user_tables where table_name like &#39;%&#39;||20160530||&#39;%&#39;; BEGIN   
OPEN P_Cursor;   
LOOP FETCH P_Cursor INTO l_sql;     
EXIT WHEN P_Cursor%NOTFOUND;     
IF l_sql IS NOT NULL THEN       
EXECUTE IMMEDIATE l_sql;     
END IF;   
END LOOP;   
CLOSE P_Cursor; 
END;
</code></pre>

<h3 id="toc_2">3.  查看表空间文件编号</h3>

<p><code>select file#,name from v$datafile where name like &#39;%daily.dbf&#39;;</code> </p>

<h3 id="toc_3">4.  查看表空间文件最大存储块号</h3>

<p><code>select max(block_id) from dba_extents where file_id=5;</code> </p>

<h3 id="toc_4">5.  计算文件中最大使用块占用的位置</h3>

<p><code>select 134217728*8/1024 from dual;   ---将block_id乘以8除以1024将得到占用块的位置，用byte为单位</code> <br/>
<code>select 1048576/1024/1024 from dual;   ---如果在除以两个1024可以得到M单位的数值</code> </p>

<p>通过计算出来的数值可以确定目前resize表空间，可以使用的最小大小 </p>

<h3 id="toc_5">6.  查看每个表存储的起始位置</h3>

<pre class="line-numbers"><code class="language-sql">select min(block_id),segment_name 
from dba_extents 
where file_id = 5 group by segment_name 
order by min(block_id) 
desc
</code></pre>

<p>如果表空间有很多剩余，而表存储位置离散，可以紧缩表，将高为表move到低位 </p>

<h3 id="toc_6">7.  移动大于一定block值的表</h3>

<pre class="line-numbers"><code class="language-sql">declare   
l_sql CLOB;   
CURSOR P_Cursor is SELECT DISTINCT &#39;alter table &#39; || segment_name || &#39; move tablespace DAILY_BK&#39;
FROM dba_extents
WHERE tablespace_name = &#39;DAILY&#39; 
AND file_id = 5    
AND block_id &gt; 134217728    
AND segment_type = &#39;TABLE&#39;; 
BEGIN   
OPEN P_Cursor;   
LOOP     
FETCH P_Cursor       
INTO l_sql;     
EXIT WHEN P_Cursor%NOTFOUND;     
IF l_sql IS NOT NULL THEN      
EXECUTE IMMEDIATE l_sql;     
END IF;   
END LOOP;   
CLOSE P_Cursor; 
END;
</code></pre>

<p>具体使用的block_id，可以根据空闲百分比和总大小进行计算，不过一次move的数据块总量必须小于总空闲空间大小，计算方法如5中 move会消耗较长的时间。</p>

<h3 id="toc_7">8.  检查是否有不可用的索引</h3>

<pre class="line-numbers"><code class="language-sql">SELECT index_name,index_type, STATUS,partitioned, table_name
FROM User_Indexes  
Where status=&#39;UNUSABLE&#39;;
</code></pre>

<p>移动完成后表的索引会失效，查询是否有失效索引，然后rebuild索引。 </p>

<h3 id="toc_8">9.  再次查看表空间最大block号</h3>

<pre class="line-numbers"><code class="language-sql">SELECT MAX(block_id) 
FROM dba_extents
WHERE tablespace_name = &#39;DAILY&#39;;
</code></pre>

<h3 id="toc_9">10. 缩减表空间</h3>

<p>按照9中的最大block号计算出可缩小的最小空间大小，resize <br/>
<code>alter database datafile &#39;/data1/daily/daily.dbf&#39; resize 1048576M;</code> </p>

<h3 id="toc_10">11. 建立sqlmove.sh脚本</h3>

<p>move操作和删除大量数据等都会花费很长的时间，为了防止网络断开，可以使用linux脚本执行命令，如下建立脚本sqlmove.sh脚本，调用sqlmove.sql中的语句进行数据库操作。注意给予oracle用户脚本的执行权限。</p>

<pre class="line-numbers"><code class="language-bash">#!/bin/sh 
sqlplus daily/mdasil@daily 
&lt;&lt; EOF 
@/home/oracle/sqlmove.sql 
exit; EOF
</code></pre>

<h3 id="toc_11">12. 建立sqlmove.sql脚本</h3>

<pre class="line-numbers"><code class="language-sql">declare
l_sql CLOB;   
CURSOR P_Cursor is SELECT DISTINCT 
&#39;alter table &#39; || segment_name ||&#39; move&#39;FROM dba_extents 
WHERE tablespace_name = &#39;DAILY&#39;
AND file_id = 5    
AND block_id &gt; 114217728    
AND segment_type = &#39;TABLE&#39;; 
BEGIN  
OPEN P_Cursor;   
LOOP     
FETCH P_Cursor       
INTO l_sql;     
EXIT WHEN P_Cursor%NOTFOUND;     
IF l_sql IS NOT NULL THEN EXECUTE IMMEDIATE l_sql;     
END IF;   
END LOOP;   
CLOSE P_Cursor; 
END;    
/
</code></pre>

<p>Tips </p>

<blockquote>
<p>LOBSEGMENT类型数据无法move需要首先查看其属于哪个表 <br/>
<code>select * from dba_lobs where segment_name like &#39;SYS_LOB0000073562C00003$$&#39;</code> <br/>
在commid中查看表结构 <code>desc TB_LOG1</code> <br/>
使用如下语句进行移动 <br/>
<code>ALTER TABLE TB_LOG1 MOVE TABLESPACE DAILY LOB(PARAMETER,MESSGAE) STORE AS(TABLESPACE DAILY);</code> </p>
</blockquote>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle表及表空间操作记录]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640817.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640817.html</id>
    <content type="html">
<![CDATA[<h1 id="toc_0">关于表的操作</h1>

<h2 id="toc_1">表空间</h2>

<ol>
<li>查看表空间和大小</li>
</ol>

<pre class="line-numbers"><code class="language-sql">SELECT UPPER(F.TABLESPACE_NAME) &quot;表空间名&quot;, D.TOT_GROOTTE_MB
&quot;表空间大小(M)&quot;, D.TOT_GROOTTE_MB - F.TOTAL_BYTES &quot;已使用空间(M)&quot;,    
TO_CHAR(ROUND((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / 
D.TOT_GROOTTE_MB * 100,2), &#39;990.99&#39;) &quot;使用比&quot;,    F.TOTAL_BYTES 
&quot;空闲空间(M)&quot;, F.MAX_BYTES &quot;最大块(M)&quot; 
FROM ( SELECT TABLESPACE_NAME, ROUND(SUM(BYTES) / (1024 * 1024), 2) TOTAL_BYTES, 
ROUND(MAX(BYTES) / (1024 * 1024), 2) MAX_BYTES    
FROM SYS.DBA_FREE_SPACE 
GROUP BY TABLESPACE_NAME) F,    
(SELECT DD.TABLESPACE_NAME, ROUND(SUM(DD.BYTES) / (1024 * 
1024), 2) TOT_GROOTTE_MB 
FROM SYS.DBA_DATA_FILES DD 
GROUP BY DD.TABLESPACE_NAME) D 
WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME ORDER BY 4 DESC;
</code></pre>

<span id="more"></span><!-- more -->

<ol>
<li>查询表空间有那些表</li>
</ol>

<pre class="line-numbers"><code class="language-sql">select table_name from all_tables where tablespace_name = &#39;TEMP&#39;; 
</code></pre>

<ol>
<li> 查询所有用户表使用大小的前三十名</li>
</ol>

<pre class="line-numbers"><code class="language-sql">select * from (select segment_name,bytes from dba_segments
where owner = USER order by bytes desc ) where rownum &lt;= 30
――看占用空间最大的表 
select segment_name,round(bytes/1024/1024/1024) as bytes_G 
from dba_segments where owner =&#39;SQMDB&#39; order by bytes desc
</code></pre>

<ol>
<li> 建立表空间</li>
</ol>

<pre class="line-numbers"><code class="language-sql">CREATE BIGFILE TABLESPACE SQM_TRAFFIC DATAFILE
&#39;/data3/sqmmt2db/sqm_traffic.dbf&#39; SIZE 5G AUTOEXTEND ON NEXT 1G MAXSIZE 34359738344K 
NOLOGGING
ONLINE
EXTENT 
MANAGEMENT 
LOCAL 
UNIFORM 
SIZE 256K BLOCKSIZE 8K 
SEGMENT SPACE MANAGEMENT AUTO FLASHBACK ON;
</code></pre>

<ol>
<li> 表空间迁移</li>
</ol>

<pre class="line-numbers"><code class="language-sql">--查看表空间 
select * from dba_data_files where tablespace_name=&#39;SQMDB&#39;
--停掉表空间 alter tablespace SQMDB offline normal; 
--在liunx里把表空间的文件移到新地址 
--将表空间改到新地址 
alter tablespace SQMDB rename datafile &#39;/data2/sqmmt/sqmdb.dbf&#39; to &#39;/data3/sqmmt/sqmdb.dbf&#39;; 
--挂上表空间 alter tablespace SQMDB online;
</code></pre>

<h2 id="toc_2">锁</h2>

<ol>
<li> 查看数据库引起锁表的SQL语句</li>
</ol>

<pre class="line-numbers"><code class="language-sql">SELECT a.username, a.machine, a.program, a.sid, a.serial#, a.status, c.piece, c.sql_text 
FROM v session a,v sqltext c 
WHERE a.sid in ( select distinct t2.sid from v locked_object t1,v session t2 where t1.session_id=t2.sid  ) 
and a.sql_address=c.address(+) ORDER BY c.piece
</code></pre>

<ol>
<li> 查看数据库锁的情况</li>
</ol>

<pre class="line-numbers"><code class="language-sql">---查看数据库锁的情况必须要有DBA权限  
select object_id,session_id,locked_mode from v locked_object;  
select t2.username,t2.sid,t2.serial#,t2.logon_time  
from v locked_object t1,v session t2  
where t1.session_id=t2.sid order by t2.logon_time;
</code></pre>

<ol>
<li> 查看被锁的表</li>
</ol>

<pre class="line-numbers"><code class="language-sql">select p.spid,a.serial#,c.object_name,b.session_id,
b.oracle_username,b.os_user_name 
from v process p,v session a, v locked_object b,all_objects  c 
where p.addr=a.paddr and a.process=b.process and c.object_id=b.object_id;
</code></pre>

<ol>
<li> 杀掉进程 </li>
</ol>

<pre class="line-numbers"><code class="language-sql">alter system kill session &#39;sid,serial#&#39;; 
alter system kill session &#39;3964,51752&#39; immediate;
</code></pre>

<blockquote>
<p>注意，上例中SID为到(USERNAME列为空)的会话，是Oracle的后台进程，不要对这些会话进行任何操作。</p>
</blockquote>

<h2 id="toc_3">查看连接</h2>

<ol>
<li> 查看连接数
<code>select count(*) from v session;</code></li>
<li> 查看并发连接数
<code>Select count(*) from v session where status=&#39;ACTIVE&#39;;</code></li>
<li>查看连接的进程
<code>SELECT sid, serial#, username, osuser FROM v session;</code> </li>
<li> 查看数据库使用的裸设备</li>
</ol>

<pre class="line-numbers"><code class="language-sql">select * from dba_data_files order by file_name; 
select * from dba_temp_files  order by file_name; 
select * from v controlfile; select * from v logfile;
</code></pre>

<blockquote>
<p>具体的方法是查询<code>dba_data_files</code>，<code>dba_temp_files</code>，<code>v controlfile</code>和<code>v logfile</code>看这四类文件具体占用的裸设备</p>
</blockquote>

<h2 id="toc_4">查看表占空间</h2>

<ol>
<li>查看表所占空间</li>
</ol>

<pre class="line-numbers"><code class="language-sql">SELECT TABLESPACE_NAME, TO_CHAR(SUM(BYTES)/(1024*1024),&#39;999G999D999&#39;) CNT_MB 
FROM DBA_EXTENTS WHERE OWNER=&#39;&amp;OWNER&#39; AND 
SEGMENT_NAME=&#39;&amp;TABLE_NAME&#39; AND SEGMENT_TYPE LIKE &#39;TABLE%&#39;
GROUP BY TABLESPACE_NAME;
</code></pre>

<ol>
<li>几种情况</li>
</ol>

<p>有两种含义的表大小。一种是分配给一个表的物理空间数量，而不管空间是否被使用。可以这样查询获得字节数：</p>

<pre class="line-numbers"><code class="language-sql">select segment_name, bytes from user_segments 
where segment_type = &#39;TABLE&#39;; 
</code></pre>

<pre class="line-numbers"><code class="language-sql">Select Segment_Name,Sum(bytes)/1024/1024 From User_Extents
Group By Segment_Name
</code></pre>

<p>另一种表实际使用的空间。这样查询：</p>

<pre class="line-numbers"><code class="language-sql">analyze table emp compute statistics;  select num_rows * 
avg_row_len  from user_tables  where table_name = &#39;EMP&#39;;
</code></pre>

<p>查看每个表空间的大小</p>

<pre class="line-numbers"><code class="language-text">Select Tablespace_Name,Sum(bytes)/1024/1024 From Dba_Segments 
Group By Tablespace_Name
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant单机虚拟集群]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640854.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640854.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">Vagrant初步使用</h2>

<p>Vagrant本为方便移植开发环境出现，正是因为该目的，可以部署好一台虚拟机从而copy出多个生成集群，例如虚拟Spark环境，只需要部署好一台，即可通过修改Vagrantfile生成多台，达到虚拟集群部署。再加上Ansible工具，可以大大节省部署时间。</p>

<h3 id="toc_1">基础环境需求：</h3>

<ul>
<li>VirtualBox虚拟机，Mac，Linux，Windows系统全部支持，<a href="https://www.virtualbox.org/wiki/Downloads">官网</a>下载一步步安装即可。</li>
<li>Vagrant，全平台支持，同样<a href="https://www.vagrantup.com/downloads.html">官网</a>下载一步步安装即可。</li>
</ul>

<p>通过Vagrant管理虚拟机，可以直接从<a href="http://www.vagrantbox.es">官方镜像地址</a>Down别人制作好的box，一般也就几百MB，也可以自己制作box来使用。</p>

<span id="more"></span><!-- more -->

<h3 id="toc_2">Vagrant环境介绍</h3>

<p>Vagrant主要有两个工作环境：</p>

<ul>
<li>默认下载box等路径<code>/User/username/.vagrant.d/</code></li>
<li>自建存放<code>Vagrantfile</code>文件以及启动虚拟机等路径，如：/home/username/vagrant/`</li>
</ul>

<p>默认路径主要存放私钥，下载box，box下载失败临时文件等路径，<strong>自己制作的box</strong>导入也会在该路径产生相应文件。</p>

<p>自建路径主要用于平时操作虚拟机，例如<code>vagrant ssh</code>等操作。</p>

<h3 id="toc_3">基本命令</h3>

<p>安装好软件以后，可以通过<code>vagrant -h</code>查看帮助手册，对每个命令会有详细的解释，各命令详细解释也可查看，如<code>vagrant box -h</code>查看对box操作的方法。<code>vagrant -v</code>查看版本。</p>

<p>一般安装好之后主要使用如下命令：</p>

<ul>
<li>初始化工作环境：<code>vagrant init</code></li>
<li>启动虚拟机：<code>vagrant up</code></li>
<li>ssh连接虚拟机：<code>vagrant ssh</code></li>
<li>关闭虚拟机：<code>vagrant halt</code></li>
</ul>

<p>以下是<code>vagrant -h</code>之后结果：</p>

<pre class="line-numbers"><code class="language-text">Usage: vagrant [options] &lt;command&gt; [&lt;args&gt;]

    -v, --version                    Print the version and exit.
    -h, --help                       Print this help.

Common commands:
     box             manages boxes: installation, removal, etc.
     connect         connect to a remotely shared Vagrant environment
     destroy         stops and deletes all traces of the vagrant machine
     global-status   outputs status Vagrant environments for this user
     halt            stops the vagrant machine
     help            shows the help for a subcommand
     init            initializes a new Vagrant environment by creating a Vagrantfile
     login           log in to HashiCorp&#39;s Atlas
     package         packages a running vagrant environment into a box
     plugin          manages plugins: install, uninstall, update, etc.
     port            displays information about guest port mappings
     powershell      connects to machine via powershell remoting
     provision       provisions the vagrant machine
     push            deploys code in this environment to a configured destination
     rdp             connects to machine via RDP
     reload          restarts vagrant machine, loads new Vagrantfile configuration
     resume          resume a suspended vagrant machine
     share           share your Vagrant environment with anyone in the world
     snapshot        manages snapshots: saving, restoring, etc.
     ssh             connects to machine via SSH
     ssh-config      outputs OpenSSH valid configuration to connect to the machine
     status          outputs status of the vagrant machine
     suspend         suspends the machine
     up              starts and provisions the vagrant environment
     validate        validates the Vagrantfile
     version         prints current and latest Vagrant version

For help on any individual command run `vagrant COMMAND -h`

Additional subcommands are available, but are either more advanced
or not commonly used. To see all subcommands, run the command
`vagrant list-commands`.
</code></pre>

<h2 id="toc_4">自制Vagrant box</h2>

<h3 id="toc_5">初次使用自制box</h3>

<p>建议通过Vagrant默认的<code>vagran</code>用户管理，熟悉后可自定义各种需求。需要在操作系统中做如下操作后打包：</p>

<ul>
<li>新建<code>vagrant</code>用户和用户目录，密码为<code>vagrant</code></li>
<li>添加<code>vagrant</code>用户公钥文件，路径为<code>/home/vagrant/.ssh/authorized_keys</code></li>
</ul>

<h3 id="toc_6">自制root用户box</h3>

<p>现实中很多操作通过<code>vagrant</code>用户会有很多不便利，更喜欢通过<code>root</code>用户操作，此时必须修改<code>Vagrantfile</code>文件，指定登录用户为<code>root</code>用户。具体需要做如下操作：</p>

<ul>
<li>在真机生成<code>root</code>用户的密钥对，将公钥添加到虚拟机中，可参考该<a href="https://biohyper.github.io/2017/03/31/%E5%AF%86%E9%92%A5--%E5%85%8D%E5%AF%86SSH%E4%BA%92%E4%BF%A1/">文章</a></li>
<li>将真机私钥移动到Vagrant默认存放私钥路径，可通过<code>vagrant ssh-config</code>命令查看存放路径。Linux为：<code>/root/.vagrant.d/insecure_private_key</code>，如果已经存在该文件，直接覆盖即可</li>
<li>在真机中打包虚拟操作系统，步骤如下：<br/>
进入目录：<code>cd /User/username/VirtualBox VMs/centos(实际虚拟机名hceng)/</code><br/>
执行打包命令：<code>vagrant package --base centos(实际虚拟机名称) --output (自定义名称).box</code></li>
<li>将打包好的box文件移动到vagrant环境路径，添加box：<code>vagrant box add name(自定义) package.box</code></li>
</ul>

<p>此时自己需求的Vagrant box就已经制作好了，可以发布给其他同事使用。</p>

<blockquote>
<p>不论使用哪个用户登录，建议保留<code>vagrant</code>用户，且第一次登录使用默认的<code>vagrant</code>用户，因为每台机器的私钥都是不同的，但是<code>vagrant</code>私钥是固定的，它使用了同一的公钥文件。这样方便其他人自定义。</p>
</blockquote>

<h2 id="toc_7">Vagrantfile文件 -- Vagrant的关键</h2>

<p>各种自定义话配置都在<code>Vagrantfile</code>文件中，Vagrant为<code>ruby</code>语言编写，所以配置文件遵循<code>ruby</code>语法。以下为虚拟集群示例：</p>

<pre class="line-numbers"><code class="language-ruby"># -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.box = &quot;spark_master&quot;
  
  config.vm.define :master do |master|
          master.vm.hostname = &quot;master&quot;
          master.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.50&quot;
          master.ssh.username = &quot;root&quot;  # 指定root用户登录，注释则默认vagrant用户登录
          # master.ssh.password = &quot;password&quot;   # 登录用户密码
          # master.ssh.insert_key = false      # 关闭密钥认证方式
          master.vm.provider &quot;virtualbox&quot; do |v|
                  v.name = &quot;master-50&quot;
                  v.memory = &quot;18432&quot;
                  v.cpus = &quot;12&quot;
          end
  end
  config.vm.define :slaver1 do |slaver1|
          slaver1.vm.hostname = &quot;slaver1&quot;
          slaver1.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.51&quot;
          slaver1.ssh.username = &quot;root&quot;
          # slaver1.ssh.password = &quot;password&quot;
          # slaver1.ssh.insert_key = false
          slaver1.vm.provider &quot;virtualbox&quot; do |v|
                  v.name = &quot;slaver1-51&quot;
                  v.memory = &quot;12288&quot;
                  v.cpus = &quot;6&quot;
          end
  end
  config.vm.define :slaver2 do |slaver2|
          slaver2.vm.hostname = &quot;slaver2&quot;
          slaver2.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.52&quot;
          slaver2.ssh.username = &quot;root&quot;
          # slaver2.ssh.password = &quot;password&quot;
          # slaver2.ssh.insert_key = false
          slaver2.vm.provider &quot;virtualbox&quot; do |v|
                  v.name = &quot;slaver2-52&quot;
                  v.memory = &quot;12288&quot;
                  v.cpus = &quot;6&quot;
          end
  end
  config.vm.define :slaver3 do |slaver3|
          slaver3.vm.hostname = &quot;slaver3&quot;
          slaver3.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.53&quot;
          slaver3.ssh.username = &quot;root&quot;
          # slaver3.ssh.password = &quot;password&quot;
          # slaver3.ssh.insert_key = false
          slaver3.vm.provider &quot;virtualbox&quot; do |v|
                  v.name = &quot;slaver3-53&quot;
                  v.memory = &quot;12288&quot;
                  v.cpus = &quot;6&quot;
          end
  end
end
</code></pre>

<p>配置好以后就可以执行<code>vagrant up</code>启动虚拟机，当虚拟机为集群状态，该命令则会启动所有虚拟机，单独启动需要指定虚拟机名称，例如<code>vagrant up master</code></p>

<h2 id="toc_8">备忘&amp;&amp;技巧</h2>

<ul>
<li><p>每次敲<code>vagrant</code>命令繁琐可以通过编辑<code>.bashrc</code>文件，增加<code>alias vg=“vagrant”</code>使得之后用<code>vg</code>代替<code>vagrant</code>命令。</p></li>
<li><p>配置文件可以通过循环配置，节约时间，节省代码：</p></li>
</ul>

<pre class="line-numbers"><code class="language-ruby">  
  (1..4).each do |i|

    config.vm.define &quot;node#{i}&quot; do |node|

       node.vm.box = &quot;laravel/homestead&quot;    # 设置虚拟机的Box
        
        node.vm.hostname=&quot;node#{i}&quot;    # 设置虚拟机的主机名

        node.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.1#{i}&quot;    # 设置虚拟机hostonly模式的IP

        node.vm.synced_folder &quot;F:/workSpace/quickstart1&quot;, &quot;/home/vagrant/share&quot;    # 设置虚拟机的IP # 设置主机与虚拟机的共享目录
 
        node.vm.provider &quot;virtualbox&quot; do |v|    # VirtaulBox相关配置

            v.name = &quot;node#{i}&quot;    # 设置虚拟机的名称

            v.memory = 2048    # 设置虚拟机的内存大小

            v.cpus = 1    # 设置虚拟机的CPU个数
        end
    end
</code></pre>

<ul>
<li>多个虚拟机将会占用很多磁盘空间，可以提前修改Virtualbox的虚拟机存放路径
<code>VBoxManage setproperty machinefolder /data/VirtualBoxVms</code></li>
</ul>

<h2 id="toc_9">错误记录</h2>

<p>在迁移到其他机器出现认证失败的错误，即长时间无法通过ssh登录：</p>

<pre class="line-numbers"><code class="language-text">localvm2: Warning: Remote connection disconnect. Retrying...
localvm2: Warning: Authentication failure. Retrying...
</code></pre>

<p>这种情况大多为本机密钥和虚拟机公钥不匹配，可以通过修改<code>Vagrantfile</code>使用用户名密码登录，也可重新匹配私钥和公钥。参考该<a href="https://biohyper.github.io/2017/03/31/%E5%AF%86%E9%92%A5--%E5%85%8D%E5%AF%86SSH%E4%BA%92%E4%BF%A1/">文章</a></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac主机VirtualBox中调整Linux系统磁盘大小]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640889.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640889.html</id>
    <content type="html">
<![CDATA[<p>研究虚拟机搭建Hadoop环境，过程中master主机出现磁盘容量不足问题，查阅资料后解决，作此记录。</p>

<h2 id="toc_0">准备工作</h2>

<p>查看虚拟机中虚拟磁盘的的分区表，确认当前大小以及自己要扩到多大。<br/>
因安装虚拟机已是很久前，到用时才发现曾经只分配了8G硬盘容量(我当时是有多小气😭)，以下是命令：</p>

<span id="more"></span><!-- more -->

<pre class="line-numbers"><code class="language-bash">[root@c0 opt]# fdisk -l

Disk /dev/sda: 8589 MB, 8589934592 bytes
255 heads, 63 sectors/track, 1044 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00017d52

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          64      512000   83  Linux
Partition 1 does not end on cylinder boundary.
/dev/sda2              64        1045     7875584   8e  Linux LVM

Disk /dev/mapper/vg_c0-lv_root: 7205 MB, 7205814272 bytes
255 heads, 63 sectors/track, 876 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000


Disk /dev/mapper/vg_c0-lv_swap: 855 MB, 855638016 bytes
255 heads, 63 sectors/track, 104 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000
</code></pre>

<h2 id="toc_1">VirtualBox增加磁盘熔炼</h2>

<p>在<code>Mac</code>和<code>Linux</code>中需要使用<code>VirtualBox</code>的命令行调整虚拟机的磁盘分配.</p>

<p><code>VirtualBox</code>的说明文档中明确给出了调整虚拟机磁盘大小的方法：</p>

<pre class="line-numbers"><code class="language-text">VBoxManage modifyhd         &lt;uuid&gt;|&lt;filename&gt;
                            [--type normal|writethrough|immutable|shareable|
                                    readonly|multiattach]
                            [--autoreset on|off]
                            [--compact]
                            [--resize &lt;megabytes&gt;|--resizebyte &lt;bytes&gt;]
</code></pre>

<h3 id="toc_2">查看可以修改的磁盘</h3>

<p><code>VBoxManage list hdds</code>命令是用来查看有哪些虚拟机的磁盘可供修改，包括了磁盘路径和<code>UUID</code>，如下：</p>

<pre class="line-numbers"><code class="language-text">$ VBoxManage list hdds
UUID:           b81ac2f6-a6a9-434a-9aab-c92858be6d24
Parent UUID:    base
State:          created
Type:           normal (base)
Location:       /Users/yourname/VirtualBox VMs/c0/c0.vdi
Storage format: VDI
Capacity:       30720 MBytes
Encryption:     disabled

UUID:           c3700bb3-a51d-4bff-ac76-578dfcde63d1
Parent UUID:    base
State:          locked write
Type:           normal (base)
Location:       /Users/yourname/VirtualBox VMs/c1/c1.vdi
Storage format: VDI
Capacity:       20479 MBytes
Encryption:     disabled
</code></pre>

<h3 id="toc_3">修改系统磁盘大小</h3>

<p><code>modifyhd</code>指令就是用来调整磁盘大小的。对象可以是虚拟机的<code>uuid</code>，也可以直接指定要调整大小的虚拟机磁盘文件名(全路径)。</p>

<pre class="line-numbers"><code class="language-text">$ VBoxManage modifyhd &quot;/Users/yourname/VirtualBox VMs/c0/c0.vdi&quot; --resize 30720
0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
</code></pre>

<p>以上命令是将<code>/Users/yourname/VirtualBox VMs/c0/c0.vdi</code>磁盘重新调整为30G，<code>resize</code>参数默认单位是<code>MB</code>。</p>

<blockquote>
<p>修改是虚拟机状态必须是<strong>关闭</strong>状态。如果该虚拟机有快照（snapshot），则只有在删除快照后才能在虚拟机客户系统里看到更改后的磁盘容量。</p>
</blockquote>

<h2 id="toc_4">CentOS 的 LVM 管理</h2>

<p>重新启动该虚拟机，再次查看磁盘情况：</p>

<pre class="line-numbers"><code class="language-bash">[root@c0 ~]# fdisk -l

Disk /dev/sda: 32.2 GB, 32212254720 bytes
255 heads, 63 sectors/track, 3916 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00017d52

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          64      512000   83  Linux
Partition 1 does not end on cylinder boundary.
/dev/sda2              64        1045     7875584   8e  Linux LVM

Disk /dev/mapper/vg_c0-lv_root: 7205 MB, 7205814272 bytes
255 heads, 63 sectors/track, 876 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000


Disk /dev/mapper/vg_c0-lv_swap: 855 MB, 855638016 bytes
255 heads, 63 sectors/track, 104 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000
</code></pre>

<p>此时，磁盘容量已经为30G，磁盘占用情况却没有发生变化：</p>

<pre class="line-numbers"><code class="language-bash">[root@c0 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/vg_c0-lv_root
                      6.5G  5.5G  663M  90% /
tmpfs                 499M     0  499M   0% /dev/shm
/dev/sda1             477M   65M  387M  15% /boot
</code></pre>

<p>试试看用 dd 命令创建一个大小为 1GB 的块文件：</p>

<pre class="line-numbers"><code class="language-bash"># dd if=/dev/zero of=1.0G.img bs=1M count=1000
dd: writing `1.0G.img&#39;: No space left on device
1+0 records in
0+0 records out
8192 bytes (8.2 kB) copied, 0.00300509 s, 2.7 MB/s
</code></pre>

<p>提示说磁盘空间不足（No space left on device）。虽然我们给了虚拟机足够的空间，但是虚拟机里的系统（这里是 CentOS）并没有将这一部分空间利用上。可以看到，虚拟机里的磁盘空间只有 1.7G，原始分配的 3G 没有用完。这同时也说明，即使创建虚拟机的时候使用动态分配磁盘大小，虚拟机里的系统也并不会自动修改自己的磁盘。如果是正常使用，即使虚拟机的虚拟磁盘足够大，还是可能会在虚拟机中遇到磁盘空间不足的警告。</p>

<p>下面调整虚拟机中操作系统的文件系统，使之将所有空间利用上。</p>

<h3 id="toc_5">将空余磁盘创建为<code>sda3</code></h3>

<p>重新启动虚拟机，登入 CentOS，使用 fdisk 将虚拟磁盘的空闲空间创建为一个新的分区。注意要使用代表 Linux LVM 的分区号 8e 来作为 ID。</p>

<pre class="line-numbers"><code class="language-bash">[root@c0 ~]# fdisk /dev/sda

WARNING: DOS-compatible mode is deprecated. It&#39;s strongly recommended to
         switch off the mode (command &#39;c&#39;) and change display units to
         sectors (command &#39;u&#39;).
Command (m for help): p

Disk /dev/sda: 32.2 GB, 32212254720 bytes
255 heads, 63 sectors/track, 3916 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00017d52

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          64      512000   83  Linux
Partition 1 does not end on cylinder boundary.
/dev/sda2              64        1045     7875584   8e  Linux LVM

Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 3
First cylinder (1045-3916, default 1045): t
First cylinder (1045-3916, default 1045):
Using default value 1045
Last cylinder, +cylinders or +size{K,M,G} (1045-3916, default 3916):
Using default value 3916

Command (m for help): t
Partition number (1-4): 3

Hex code (type L to list codes): L

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris
 1  FAT12           39  Plan 9          82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      3c  PartitionMagic  83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       40  Venix 80286     84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 &lt;32M      41  PPC PReP Boot   85  Linux extended  c7  Syrinx
 5  Extended        42  SFS             86  NTFS volume set da  Non-FS data
 6  FAT16           4d  QNX4.x          87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS       4e  QNX4.x 2nd part 88  Linux plaintext de  Dell Utility
 8  AIX             4f  QNX4.x 3rd part 8e  Linux LVM       df  BootIt
 9  AIX bootable    50  OnTrack DM      93  Amoeba          e1  DOS access
 a  OS/2 Boot Manag 51  OnTrack DM6 Aux 94  Amoeba BBT      e3  DOS R/O
 b  W95 FAT32       52  CP/M            9f  BSD/OS          e4  SpeedStor
 c  W95 FAT32 (LBA) 53  OnTrack DM6 Aux a0  IBM Thinkpad hi eb  BeOS fs
 e  W95 FAT16 (LBA) 54  OnTrackDM6      a5  FreeBSD         ee  GPT
 f  W95 Ext&#39;d (LBA) 55  EZ-Drive        a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            56  Golden Bow      a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    5c  Priam Edisk     a8  Darwin UFS      f1  SpeedStor
12  Compaq diagnost 61  SpeedStor       a9  NetBSD          f4  SpeedStor
14  Hidden FAT16 &lt;3 63  GNU HURD or Sys ab  Darwin boot     f2  DOS secondary
16  Hidden FAT16    64  Novell Netware  af  HFS / HFS+      fb  VMware VMFS
17  Hidden HPFS/NTF 65  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE
18  AST SmartSleep  70  DiskSecure Mult b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 75  PC/IX           bb  Boot Wizard hid fe  LANstep
1c  Hidden W95 FAT3 80  Old Minix       be  Solaris boot    ff  BBT
1e  Hidden W95 FAT1
Hex code (type L to list codes): 8e
Changed system type of partition 3 to 8e (Linux LVM)

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.

WARNING: Re-reading the partition table failed with error 16: Device or resource busy.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.
</code></pre>

<p>简化后操作如下：</p>

<pre class="line-numbers"><code class="language-text"># fdisk /dev/sda
  n {new partition}
  p {primary partition}
  3 {partition number}
# 此处回车
  t {change partition id}
  3 {partition number}
  8e {Linux LVM partition}
  w
</code></pre>

<p>再次查看分区表，发现sda3已经成功创建</p>

<pre class="line-numbers"><code class="language-bash">[root@c0 ~]# fdisk -l

Disk /dev/sda: 32.2 GB, 32212254720 bytes
255 heads, 63 sectors/track, 3916 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00017d52

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          64      512000   83  Linux
Partition 1 does not end on cylinder boundary.
/dev/sda2              64        1045     7875584   8e  Linux LVM
/dev/sda3            1045        3916    23066662   8e  Linux LVM

Disk /dev/mapper/vg_c0-lv_root: 7205 MB, 7205814272 bytes
255 heads, 63 sectors/track, 876 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000


Disk /dev/mapper/vg_c0-lv_swap: 855 MB, 855638016 bytes
255 heads, 63 sectors/track, 104 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000
</code></pre>

<p>调整后重启下，保证稳妥，不确定不重启是否会正常。</p>

<h3 id="toc_6">调整 LVM 大小</h3>

<p>先看看当前 Volume Group：</p>

<pre class="line-numbers"><code class="language-bash">[root@c0 ~]# vgdisplay
  --- Volume group ---
  VG Name               vg_c0
  System ID
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  3
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                2
  Open LV               2
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               7.51 GiB
  PE Size               4.00 MiB
  Total PE              1922
  Alloc PE / Size       1922 / 7.51 GiB
  Free  PE / Size       0 / 0
  VG UUID               YdmWnX-Tle4-ovBs-FtPa-0r0R-OWel-h6NXW7
</code></pre>

<p>名称为<code>vg_c0</code>，可调整大小（resizable），当前大小为<code>7.51GB</code>。<br/>
活动的 LVM 卷通过以下命令查看：</p>

<pre class="line-numbers"><code class="language-bash">[root@c0 ~]# lvscan
  ACTIVE            &#39;/dev/vg_c0/lv_root&#39; [6.71 GiB] inherit
  ACTIVE            &#39;/dev/vg_c0/lv_swap&#39; [816.00 MiB] inherit
</code></pre>

<p>先将分配过来的新磁盘空间创建为一个新的物理卷，</p>

<pre class="line-numbers"><code class="language-text">[root@c0 ~]# pvcreate /dev/sda3
  Physical volume &quot;/dev/sda3&quot; successfully created
</code></pre>

<p>然后使用新的物理卷来扩展<code>LVM</code>的<code>Volume Group</code>此处为<code>cg_c0</code></p>

<pre class="line-numbers"><code class="language-text">[root@c0 ~]# vgextend vg_c0 /dev/sda3
  Volume group &quot;vg_c0&quot; successfully extended

</code></pre>

<p>然后扩展 LVM 的逻辑卷 VolGroup-lv_root，</p>

<pre class="line-numbers"><code class="language-text">[root@c0 ~]# lvextend /dev/vg_c0/lv_root  /dev/sda3
  Size of logical volume vg_c0/lv_root changed from 6.71 GiB (1718 extents) to 28.71 GiB (7349 extents).
  Logical volume lv_root successfully resized.
</code></pre>

<p>最后，调整逻辑卷文件系统的大小，</p>

<pre class="line-numbers"><code class="language-text">[root@c0 ~]# resize2fs /dev/vg_c0/lv_root
resize2fs 1.41.12 (17-May-2010)
Filesystem at /dev/vg_c0/lv_root is mounted on /; on-line resizing required
old desc_blocks = 1, new_desc_blocks = 2
Performing an on-line resize of /dev/vg_c0/lv_root to 7525376 (4k) blocks.
The filesystem on /dev/vg_c0/lv_root is now 7525376 blocks long.
</code></pre>

<p>完成。看看效果：</p>

<pre class="line-numbers"><code class="language-text">[root@c0 ~]# lvscan
  ACTIVE            &#39;/dev/vg_c0/lv_root&#39; [28.71 GiB] inherit
  ACTIVE            &#39;/dev/vg_c0/lv_swap&#39; [816.00 MiB] inherit
</code></pre>

<pre class="line-numbers"><code class="language-text">  [root@c0 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/vg_c0-lv_root
                       29G  5.6G   22G  21% /
tmpfs                 499M     0  499M   0% /dev/shm
/dev/sda1             477M   65M  387M  15% /boot
</code></pre>

<blockquote>
<p>另外，几个有用的 LVM 指令（lvm2）：<br/>
lvmdiskscan<br/>
vgdisplay<br/>
pvdisplay<br/>
lvdispay<br/>
vgcreate<br/>
pvcreate<br/>
lvscan<br/>
pvscan<br/>
vgscan</p>
</blockquote>

<p>部分结果如下：</p>

<pre class="line-numbers"><code class="language-text">[root@c0 opt]# lvmdiskscan
  /dev/ram0          [      16.00 MiB]
  /dev/root          [      28.71 GiB]
  /dev/ram1          [      16.00 MiB]
  /dev/sda1          [     500.00 MiB]
  /dev/vg_c0/lv_swap [     816.00 MiB]
  /dev/ram2          [      16.00 MiB]
  /dev/sda2          [       7.51 GiB] LVM physical volume
  /dev/ram3          [      16.00 MiB]
  /dev/sda3          [      22.00 GiB] LVM physical volume
  /dev/ram4          [      16.00 MiB]
  /dev/ram5          [      16.00 MiB]
  /dev/ram6          [      16.00 MiB]
  /dev/ram7          [      16.00 MiB]
  /dev/ram8          [      16.00 MiB]
  /dev/ram9          [      16.00 MiB]
  /dev/ram10         [      16.00 MiB]
  /dev/ram11         [      16.00 MiB]
  /dev/ram12         [      16.00 MiB]
  /dev/ram13         [      16.00 MiB]
  /dev/ram14         [      16.00 MiB]
  /dev/ram15         [      16.00 MiB]
  2 disks
  17 partitions
  0 LVM physical volume whole disks
  2 LVM physical volumes
</code></pre>

<pre class="line-numbers"><code class="language-[root@c0">  --- Physical volume ---
  PV Name               /dev/sda2
  VG Name               vg_c0
  PV Size               7.51 GiB / not usable 3.00 MiB
  Allocatable           yes (but full)
  PE Size               4.00 MiB
  Total PE              1922
  Free PE               0
  Allocated PE          1922
  PV UUID               p8JU8y-uZfb-Ytjl-zjSa-ueLz-SGhs-a8qqC8

  --- Physical volume ---
  PV Name               /dev/sda3
  VG Name               vg_c0
  PV Size               22.00 GiB / not usable 2.04 MiB
  Allocatable           yes (but full)
  PE Size               4.00 MiB
  Total PE              5631
  Free PE               0
  Allocated PE          5631
  PV UUID               84lY2p-POLa-5g2L-m8pZ-NVWO-UyLg-zWLIWS
</code></pre>

<p>该文章参考<a href="https://cnzhx.net/blog/resizing-lvm-centos-virtualbox-guest/">水景一页</a>，感谢作者!</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单用户模式修改系统文件]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640924.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640924.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">场景：</h2>

<ol>
<li>因为在<code>/etc/fstab</code>写错<code>UUID</code>，导致系统无法正常启动，自动进入单用户模式；</li>
<li>当出现系统无法正常启动时，也可手动进入Linux单用户模式，从而修改一些系统文件（如<code>/etc/fstab</code>等），然后重启系统</li>
<li>系统默认只挂载<code>/</code>文件系统，因此如果<code>/usr</code>, <code>/var</code>等是单独的文件系统的话，需要分别挂载它们，否则一些命令用不了，如<code>vim</code>，会提示没有该命令。可以使用<code>mount -a</code>选项一次挂载<code>fstab</code>中的所有文件系统（noauto除外)。</li>
<li>如果没有正常关机可能还要用<code>fsck</code>检查文件系统</li>
</ol>

<span id="more"></span><!-- more -->

<h3 id="toc_1">手动进入单用户模式：</h3>

<ul>
<li>当重启Linux系统，出现系统选择页面时，按<code>e</code></li>
<li>找到<code>kernal</code>行，按<code>e</code></li>
<li>在行后输入：<strong>空格</strong> <code>single</code>，然后回车</li>
<li>然后按<code>b</code>，开始重新引导系统</li>
</ul>

<h3 id="toc_2">修改相关系统文件：</h3>

<p>进入单用户模式后，通常<code>/</code>分区（根分区）会以只读模式<code>mount</code>，故系统文件都是只读的，无法修改。<br/>
故需将根分区重新mount为可读写状态：</p>

<p><code>mount / -o rw,remount</code></p>

<p>然后修改系统文件（如/etc/fstab等），重启系统即可</p>

<h3 id="toc_3">fuser使用：</h3>

<p>当需要修改文件系统的挂载点时，如将<code>/dev/sda3</code>由<code>/mnt</code>更改至<code>/data2</code>挂载点时，会出现报错：<code>device is busy</code>，因为此时<code>/mnt</code>被其他进程占用，故无法卸载；</p>

<ul>
<li>查看挂载点被占用的进程：<code>fuser -vm /mnt</code>；</li>
<li>杀掉查出的进程连接：<code>fuser -km /mnt</code>；</li>
<li>然后重新<code>umount /mnt</code>即可</li>
</ul>

<h3 id="toc_4">fsck修复文件系统</h3>

<p>当出现文件系统错误时，可通过<code>fsck</code>命令修复：<br/>
一种常见报错为挂载时<code>mount -t ext4 /dev/sdd1 /data2</code>提示<code>can&#39;t find ext4 filesystem</code><br/>
此处报错提示可能错误，但意思应当不错，此时可通过<code>fsck -y /dev/sdd1</code>来修复该文件系统，<code>-y</code>参数是忽略过程中的确认信息需要输入的<code>yes</code></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[密钥--免密SSH互信]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636640961.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636640961.html</id>
    <content type="html">
<![CDATA[<h1 id="toc_0">两种SSH免密登录方式</h1>

<p><figure><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1xdretzc6j31900u0nf1.jpg" alt=""/></figure><br/>
<blockquote class="blockquote-center">面朝大海，春暖花开</blockquote></p>

<span id="more"></span><!-- more -->

<h3 id="toc_1">通过公钥-密钥配对实现</h3>

<p>该方法特别需要注意文件<strong>权限</strong>问题，权限不正确将会导致无法认证成功。</p>

<pre class="line-numbers"><code class="language-text">用户路径权限：755
.ssh权限：700或者744
authorized_keys权限：600
</code></pre>

<h4 id="toc_2">访问端：</h4>

<p>生成公钥和密钥文件，执行命令：<code>ssh-keygen -t rsa</code>生成<code>id_rsa</code>密钥和<code>id_rsa.pub</code>公钥，密钥文件必须保管好，公钥文件可以提供给其他任意服务器。</p>

<p>所以接下来将<code>id_rsa.pub</code>文件通过scp拷贝到其他服务器。</p>

<p>命令集合：<code>ssh-keygen -t rsa;chmod 600 ~/.ssh;scp ~/.ssh/id_dsa.pub user@$ip:/home/user/</code></p>

<h4 id="toc_3">被访问端:</h4>

<p>将<strong>访问端</strong>拷贝过来的<code>id_rsa.pub</code>文件内容追加到本机<code>authorized_keys</code>文件中，以供认证。</p>

<p>命令合集：<code>cat /home/user/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys;chmod 600 ~/.ssh/authorized_keys;chmod 755 /home/user/;chmod 700 /home/user/.ssh;</code></p>

<h3 id="toc_4">通过expect脚本实现</h3>

<blockquote>
<p>注意：</p>

<ol>
<li>脚本文件里边涉及到用户名和密码，所以必须设置好用户的权限，除了用户本人不给其他任何人读取等权限</li>
<li>一般shell脚本可以用sh来执行,<code>expect</code>脚本不能使用<code>sh</code>命令执行，否则会提示文件不可读等报错信息</li>
</ol>
</blockquote>

<p>脚本如下：</p>

<pre class="line-numbers"><code class="language-bash">#！/usr/bin/expect -f    # expect程序可通过whereis查看安装路径
set timeout 10
set id [lindex $argv 0]
set ip 192.168.1.$id
spawn ssh -l user_name@ip
expect {
&quot;yes/no&quot; {send &quot;yes\n&quot;; exp_continue}
&quot;password:&quot; {send &quot;your_password\n&quot;}
}
interact
</code></pre>

<h1 id="toc_5">公钥方法错误汇总</h1>

<p>出现ssh没有达到理想状态，可以通过<code>ssh -vvv remote_username@remote_ip</code>命令查看详细报错信息，参数<code>v</code>越多信息越详细。</p>

<h3 id="toc_6">问题一</h3>

<p>权限问题，报错信息中可以看到<code>Permission Deny</code>的报错，此时可以通过手动修改remote机器的权限，登录到remote机器检查<code>.ssh</code>目录或者<code>authorized_keys</code>权限，执行<code>chmod ~/.ssh 700</code>或者<code>chmod 600 ~/.ssh/authorized_keys</code>修复；<br/>
也可通过<code>ssh-copy-id -i /path/to/id_rsa user_name@remote_ip</code>自动修正权限问题</p>

<h3 id="toc_7">问题二</h3>

<p>查看remote机器文件权限都正常，只有ssh时候还需要密码，报错信息感到异常的有如下内容：</p>

<pre class="line-numbers"><code class="language-text">debug2: we sent a password packet, wait for reply
……
authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password
……
we did not send a packet, disable method
</code></pre>

<p>解决办法：<br/>
可以查看<code>/var/log/secure</code>是否有相关信息或者参考该<a href="http://serverfault.com/questions/321534/public-key-authentication-fails-only-when-sshd-is-daemon">文章</a>的解决办法：</p>

<blockquote>
<p>Yes, SELinux is likely the cause. The .ssh dir is probably mislabeled. Look at <code>/var/log/audit/audit.log. It should be labeled ssh_home_t</code>. Check with ls -laZ. Run <code>restorecon -r -vv /root/.ssh</code> if need be</p>
</blockquote>

<p>不错这次错误中没有看到如下信息：<br/>
<code>/var/log/audit/audit.log. It should be labeled ssh_home_t</code></p>

<h1 id="toc_8">集群中ssh公钥免密登录脚本</h1>

<p>引自博客园<a href="http://www.cnblogs.com/vovlie/archive/2012/09/16/2688020.html">记录</a>，在此感谢。</p>

<p>假设有一个1000台节点的Hadoop集群，要配置节点之间的SSH免密码登录，该如何用shell脚本实现？</p>

<h3 id="toc_9">循环1000台机器的IP地址，生成密钥文件authorized_keys</h3>

<pre class="line-numbers"><code class="language-bash">#!/bin/expect
#循环1000台机器的IP地址，生成密钥文件authorized_keys

for ip in {cat ip.list}

do

    ssh user@$ip ssh-keygen -t rsa  &amp;&gt;/dev/null

    expect{

                &quot;yes/no&quot; { send &quot;yes\r&quot;;exp_continue}

                &quot;password:&quot;{send &quot;$passwd\r&quot;;exp_continue}

              }

    cat ~/.ssh/id_rsa.pub &gt; ~/.ssh/authorized_keys &amp;&gt; /dev/null 

    exit

    if [ !-f ~/.ssh/authorized_keys ];
    then

       touch ~/.ssh/authorized_keys
    fi

    ssh user@$ip cat ~/.ssh/authorized_keys &gt;&gt; ~/.ssh/authorized_keys  &amp;&gt; /dev/null

    expect{

                &quot;yes/no&quot; { send &quot;yes\r&quot;;exp_continue}

                &quot;password:&quot;{send &quot;$passwd\r&quot;;exp_continue}

              }  

done
</code></pre>

<h3 id="toc_10">拷贝authorized_keys文件到各台机器上面</h3>

<pre class="line-numbers"><code class="language-bash">#scp authorized_keys 文件到各台机器上面

for ip in {cat ip.list}

do

   scp ~/.ssh/authorized_keys user@$ip:~/.ssh/

    expect{

                &quot;yes/no&quot; { send &quot;yes\r&quot;;exp_continue}

                &quot;password:&quot;{send &quot;$passwd\r&quot;;exp_continue}

              } 

done
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[鼠须管教]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636641006.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636641006.html</id>
    <content type="html">
<![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=31445772&auto=0&height=32"></iframe>

<h2 id="toc_0">综述</h2>

<p><strong>Rime</strong>输入法在<a href="http://rime.im">官网</a>已经介绍很清楚，这里轻微搬运。Rime输入法全平台支持，只不过称呼不同而已，对应名称如下：</p>

<ul>
<li>Mac：「鼠须管」 <code>Squirrel</code></li>
<li>Linux：「中州韻」 <code>ibus-rime</code></li>
<li>Windows：「小狼毫」 <code>Weasel</code></li>
</ul>

<p>Rime输入法的特点在于<strong><em>完全自定义</em></strong>，不用担心广告，不用担心泄漏用户数据，自己决定要如何输入，且可以针对不用应用开启不同输入方案；当你决定要使用Rime输入法的时候，就证明你对输入法的要求与众不同咯 😂😂下面就正式开始作死！！</p>

<span id="more"></span><!-- more -->

<hr/>

<p><strong><em>折腾前</em></strong><br/>
个人觉得折腾鼠须管要先确认好自己的需求，个人想法主要为了实现中文状态下<strong>半角符号</strong>快速上屏，思路仅供参考：</p>

<ul>
<li>将配置快捷键调整好，不论使用默认还是自定义，要先确定好，方便后续调整</li>
<li>外观调整为自己常用样式，这样看起来不会太累</li>
<li>实现自己的目的，如符号快速上屏等</li>
<li>扩充词库</li>
<li>备份配置以及词库</li>
</ul>

<hr/>

<h2 id="toc_1">本次配置目的</h2>

<p><strong>本次配置针对朙月拼音<code>luna_pinyin</code>最终可以实现以下目的：</strong></p>

<ul>
<li><code>#</code>号等符号快速上屏，尤其针对使用<code>Markdown</code>语法书写的同志；</li>
<li><p>皮肤及字体优化，效果如下：<br/>
<figure><img src="http://oninp1nwo.bkt.clouddn.com/fipu.jpg" alt="皮肤"/><figcaption>皮肤</figcaption></figure></p></li>
<li><p>实现类似macOS的中英文切换方式，通过大写锁定切换；<em>因个人将<code>⇪capslock</code>键与<code>⌃control</code>交换，且习惯<code>⇧shift</code>键输入大写字母，所以对<code>⇪</code>键需求不大</em></p></li>
<li><p>修改候选字翻页设置，保留<code>Windows</code>习惯用<code>+</code><code>-</code>切换，增加<code>Mac</code>的方括号<code>[</code><code>]</code>切换；修改<code>control + d</code>调用方案切换</p></li>
<li><p>配置及数据文件同步到<code>Dropbox</code>等云盘</p></li>
</ul>

<h2 id="toc_2">基本思路</h2>

<p><strong>一切以配置文件为中心</strong></p>

<p>Rime之所以可以高度自定义，是因为配置文件以及词库文件可以任意修改，只需遵循<code>YAML</code>语法就好。本人使用Mac平台，主要介绍鼠须管，配置文件基本通用的。鼠须管配置文件和数据文件存放在同一个路径<code>~/Library/Rime/</code>，也可以通过状态栏的<strong>用户设置</strong>或<code>Settings</code>打开该路径。  </p>

<p>该路径下第一次安装后会自动部署一次，产生默认的配置以及数据文件(还有写提高执行效率的编译文件，配置不需要用到)，我们需要注意的是以<code>*.dict.yaml</code>和<code>*.yaml</code>结尾的文件，有<code>dict</code>的是词库文件，后者就是我们用来自定义的主要配置(<code>dict</code>词库配置下次补充)。</p>

<blockquote>
<p>一定注意，文件要自己新建用户自定义配置，莫要修改原有文件，否则升级将会覆盖原有文件，不宜备份，也防止修改异常容易恢复<br/>
<strong>自定义文件必须在文件顶部输入<code>patch：</code>，有且只有一个</strong></p>
</blockquote>

<p><strong>本次鼠须管自定义配置主要文件如下：</strong></p>

<ul>
<li>全局配置文件: <code>default.custom.yaml</code></li>
<li>皮肤配置文件: <code>squirrel.custom.yaml</code></li>
<li>输入方案配置: <code>&lt;user plan&gt;.custom.yaml</code>, 例如我自己使用<code>luna_pinyin.custom.yaml</code></li>
<li>安装配置文件：<code>installation.yaml</code>，可配置同步到本地、U盘、云盘等路径</li>
</ul>

<h2 id="toc_3">全局配置文件</h2>

<p><strong>该文件<code>default.custom.yaml</code>主要配置全局输入选项,例如候选字数、如何切换输入方案等，默认通过「control + `」调出切换方案功能</strong><br/>
　<figure><img src="http://oninp1nwo.bkt.clouddn.com/fipu.jpg" alt="切换"/><figcaption>切换</figcaption></figure></p>

<pre class="line-numbers"><code class="language-yaml"># Rime default settings
# encoding: utf-8
patch:
  config_version: &quot;0.37&quot;
# 切换中英文配置
  ascii_composer:
    good_old_caps_lock: false
    switch_key:
      Shift_L: noop
      Shift_R: noop
      Control_L: noop
      Control_R: noop
      Caps_Lock: commit_code
      Eisu_toggle: clear

# 输入方案选择
  schema_list:
    - schema: luna_pinyin
    # - schema: terra_pinyin
    # - schema: bopomofo
    # - schema: emoji
    # - schema: bopomofo_tw
    # - schema: cangjie5
    # - schema: stroke
    # - schema: luna_pinyin_simp
    # - schema: luna_pinyin_fluency

# 输入方案切换方式
  switcher:
    caption: 〔切换方案〕
    hotkeys:
      - Control+grave
      - Control+Shift+grave
      - Control+d
    save_options:
      - full_shape
      - ascii_punct
      - simplification
      - extended_charset
    fold_options: true
    abbreviate_options: true
    option_list_separator: &#39;／&#39;

# 候选字数量
  menu:
    page_size: 9

# 按键绑定，方括号翻页
  key_binder:
    bindings:
      # Emacs style
      - { when: composing, accept: Control+p, send: Up }
      - { when: composing, accept: Control+n, send: Down }
      - { when: composing, accept: Control+b, send: Left }
      - { when: composing, accept: Control+f, send: Right }
      - { when: composing, accept: Control+a, send: Home }
      - { when: composing, accept: Control+e, send: End }
      - { when: composing, accept: Control+d, send: Delete }
      - { when: composing, accept: Control+k, send: Shift+Delete }
      - { when: composing, accept: Control+h, send: BackSpace }
      - { when: composing, accept: Control+g, send: Escape }
      - { when: composing, accept: Control+bracketleft, send: Escape }
      - { when: composing, accept: Alt+v, send: Page_Up }
      - { when: composing, accept: Control+v, send: Page_Down }
      # move by word
      - { when: composing, accept: ISO_Left_Tab, send: Shift+Left }
      - { when: composing, accept: Shift+Tab, send: Shift+Left }
      - { when: composing, accept: Tab, send: Shift+Right }
      # flip page
      - { when: has_menu, accept: minus, send: Page_Up }
      - { when: has_menu, accept: equal, send: Page_Down }
      - { when: paging, accept: bracketleft, send: Page_Up }    # 方括号‘[’翻上一页
      - { when: has_menu, accept: bracketright, send: Page_Down }    # 方括号‘]’翻下一页
      # hotkey switch
      - { when: always, accept: Control+Shift+1, select: .next }
      - { when: always, accept: Control+Shift+2, toggle: ascii_mode }
      - { when: always, accept: Control+Shift+3, toggle: full_shape }
      - { when: always, accept: Control+Shift+4, toggle: simplification }
      - { when: always, accept: Control+Shift+5, toggle: extended_charset }
      - { when: always, accept: Control+Shift+exclam, select: .next }
      - { when: always, accept: Control+Shift+at, toggle: ascii_mode }
      - { when: always, accept: Control+Shift+numbersign, toggle: full_shape }
      - { when: always, accept: Control+Shift+dollar, toggle: simplification }
      - { when: always, accept: Control+Shift+percent, toggle: extended_charset }
      - { when: always, accept: Shift+space, toggle: full_shape }
      - { when: always, accept: Control+period, toggle: ascii_punct }

# 特殊字符快速上屏
  punctuator:
    full_shape:
      &#39; &#39; : { commit: &#39;　&#39; }
      &#39;,&#39; : { commit: ， }
      &#39;.&#39; : { commit: 。 }
      &#39;&lt;&#39; : [ 《, 〈, «, ‹ ]
      &#39;&gt;&#39; : [ 》, 〉, », › ]
      &#39;/&#39; : [ ／, ÷ ]
      &#39;?&#39; : { commit: ？ }
      &#39;;&#39; : { commit: ； }
      &#39;:&#39; : { commit: ： }
      &#39;&#39;&#39;&#39; : { pair: [ &#39;‘&#39;, &#39;’&#39; ] }

    half_shape:
      &#39;/&#39; : [ 、, ､, &#39;/&#39;, ／, ÷ ]
      &#39;?&#39; : { commit: ？ }
      &#39;;&#39; : { commit: ； }
      &#39;:&#39; : { commit: ： }
      &#39;&#39;&#39;&#39; : { pair: [ &#39;‘&#39;, &#39;’&#39; ] }
      &#39;&quot;&#39; : { pair: [ &#39;“&#39;, &#39;”&#39; ] }
      &#39;\&#39; : [ 、, &#39;\&#39;, ＼ ]
      &#39;|&#39; : [ ·, ・, &#39;|&#39;, ｜, &#39;§&#39;, &#39;¦&#39;, &#39;‖&#39; ]
      &#39;!&#39; : { commit: ！ }
      &#39;@&#39; : [ &#39;@&#39;, ©, ®, ℗ ]
      &#39;#&#39; : &#39;#&#39;
      &#39;%&#39; : [ &#39;%&#39;, ％, &#39;°&#39;, &#39;℃&#39;, ‰, ‱, ℉ ]

# 邮件等智能输入
  recognizer:
    patterns:
      email: &quot;^[A-Za-z][-_.0-9A-Za-z]*@.*$&quot;
      uppercase: &quot;[A-Z][-_+.&#39;0-9A-Za-z]*$&quot;
      url: &quot;^(www[.]|https?:|ftp[.:]|mailto:|file:).*$|^[a-z]+[.].+$&quot;
      punct: &quot;^/([0-9]0?|[a-z]+)$&quot;
</code></pre>

<h2 id="toc_4">皮肤配置文件</h2>

<p><strong>该文件<code>squirrel.custom.yaml</code>配置输入法皮肤样式，如配色等</strong><br/>
示例配置为自己常用配置，仅供参考，<code>squirrel.yaml</code>中有默认主题可供选择，只需修改以下内容</p>

<pre class="line-numbers"><code class="language-text">style:
    color_scheme: apathy
</code></pre>

<p>候选词条中如果出现生显示框问号，代表缺少生僻字字体，可以在方案配色的字体指向上多加一个花园明朝<code>HanaMinA</code>字体，文件示例如下：</p>

<pre class="line-numbers"><code class="language-yaml">patch:
  us_keyboard_layout: false
  
  # options: always | never | appropriate
  show_notifications_when: appropriate  # 状态通知，适当(appropriate)，开（always）关（never）
  
  # Show notifications via Notification Center instead of Growl.

  show_notifications_via_notification_center: true
  
  style:
    color_scheme: bio
    horizontal: true        # 水平排列
    inline_preedit: false   # 单行显示，false双行显示
    corner_radius: 5        # 候选条圆角
    border_height: 0
    border_width: 0
    line_spacing: 0.2
    spacing: 2              # space between preedit and candidates in non-inline mode
    # candidate_format: &#39;%c. %@&#39;                # 编号 %c 和候选词 %@ 前后的空间
    font_face: &#39;Yuanti SC Regular,HanaMinA&#39;    # 候选词字体 supporting soft cursor &#39;›&#39;
    font_point: 14          # 候选字词大小
    # label_font_face: &#39;STHeitiTC-Medium&#39;   # 候选词编号字体
    # label_font_point: 18                  # 候选编号大小
  
  preset_color_schemes:
    bio:
      name: &quot;bio/Dark&quot;
      back_color: 0xee303030         #候选条背景色
      candidate_text_color: 0xd8e3e6   
      comment_text_color: 0x606cff     # 拼音等提示文字颜色 
      hilited_candidate_back_color: 0x19303030  # 候选文字背景色
      hilited_candidate_text_color: 0x92ff00    # 候选文字颜色
      hilited_text_color: 0xffcf9a
      text_color: 0x92f6da       # 高亮选中词颜色
</code></pre>

<h2 id="toc_5">输入方案配置文件</h2>

<p><strong>该文件<code>luna_pinyin.custom.yaml</code>确认当前方案的自定义和配置</strong></p>

<pre class="line-numbers"><code class="language-yaml"># Rime schema
# encoding: utf-8
patch:
  schema:
    schema_id: luna_pinyin
    name: 朙月拼音
    version: &quot;0.23&quot;
    dependencies:
      - emoji
      - symbols
  
  switches:
    - name: ascii_mode
      reset: 0
      states: [ 中文, 西文 ]
    - name: full_shape
      states: [ 半角, 全角 ]
    - name: simplification
      states: [ 漢字, 汉字 ]
    - name: ascii_punct
      states: [ 。，, ．， ]
  
  engine:
    processors:
      - ascii_composer
      - recognizer
      - key_binder
      - speller
      - punctuator
      - selector
      - navigator
      - express_editor
    segmentors:
      - ascii_segmentor
      - matcher
      - abc_segmentor
      - punct_segmentor
      - fallback_segmentor
    translators:
      - punct_translator
      - reverse_lookup_translator
      - script_translator
    filters:
      - simplifier
      - uniquifier
  
  speller:
    alphabet: zyxwvutsrqponmlkjihgfedcba
    delimiter: &quot; &#39;&quot;
    algebra:
      - erase/^xx$/
      - abbrev/^([a-z]).+$/$1/
      - abbrev/^([zcs]h).+$/$1/
      - derive/^([nl])ve$/$1ue/
      - derive/^([jqxy])u/$1v/
      - derive/un$/uen/
      - derive/ui$/uei/
      - derive/iu$/iou/
      - derive/([aeiou])ng$/$1gn/
      - derive/([dtngkhrzcs])o(u|ng)$/$1o/
      - derive/ong$/on/
      - derive/ao$/oa/
      - derive/([iu])a(o|ng?)$/a$1$2/
  
  translator:
    dictionary: biohyper      # 词库选择，我此处用自己新建的配置
    preedit_format:
      - xform/([nljqxy])v/$1ü/
      - xform/([nl])ue/$1üe/
      - xform/([jqxy])v/$1u/
  
  custom_phrase:
    dictionary: &quot;&quot;
    user_dict: custom_phrase
    db_class: stabledb
    enable_completion: false
    enable_sentence: false
    initial_quality: 1
  
  reverse_lookup:
    reredictionary: emoji
    rereenable_completion: false
    rereprefix: &quot;~&quot;
    tips: [emoji]
  punctuator:              # 自定义特殊符号词库文件
    import_preset: symbols

  key_binder:              # 按键绑定采用`default.yaml`文件
    import_preset: default

  recognizer:
    import_preset: default
    patterns:
      punct: &quot;^/([0-9]0?|[a-z]+)$&quot;       # 通过输入`/dn`等以`/`开头加字母可以输入特殊符号
      reverse_lookup: &quot;~[a-z]*&#39;?$&quot;
</code></pre>

<h2 id="toc_6">备份词库以及配置文件</h2>

<p>通过修改<code>installation.yaml</code>文件可以实现备份功能，通过状态栏的同步功能可实现自动同步，配置文件如下：</p>

<pre class="line-numbers"><code class="language-yaml">distribution_code_name: Squirrel
distribution_name: &quot;鼠鬚管&quot;
distribution_version: 0.9.26.2
install_time: &quot;Fri Mar 24 22:20:10 2017&quot;
installation_id: &quot;`userdefine`&quot;
rime_version: 1.2.9
sync_dir: &quot;/Users/`username`/Dropbox/Rime&quot;    # 个人网盘路径
</code></pre>

<h2 id="toc_7">结尾</h2>

<p>参考了好多帖子才搞清楚大概，这里做个记录。<br/>
上文用到的配置文件有部分配置直接从默认配置copy过来，并非自定义配置，详细可以查看<a href="https://github.com/rime/home/wiki/RimeWithSchemata#%E9%97%9C%E6%96%BC%E8%AA%BF%E8%A9%A6">官网配置</a>以及作者<a href="https://gist.github.com/lotem">示例配置</a>。<br/>
<a href="http://fonts.jp/hanazono/">花园明朝</a>字体<a href="https://www.dropbox.com/s/3sqipigs1liszao/HanaMinA.ttf?dl=0"><code>Dropbox</code>分享</a></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[构建Oracle数据库安全体系]]></title>
    <link href="https://biohyper.github.io/xiaobio/15548636641044.html"/>
    <updated>2019-04-10T10:34:24+08:00</updated>
    <id>https://biohyper.github.io/xiaobio/15548636641044.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">一、安全补丁更新</h2>

<p>及时更新数据库的安全补丁，减少数据库系统可能受到的攻击。<br/>
查看<a href="https://support.oracle.com%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%89%E5%85%A8%E8%A1%A5%E4%B8%81%E3%80%82">https://support.oracle.com，下载并安装相关的安全补丁。</a><br/>
参考Oracle厂商建议，仅对已发现的特定漏洞或缺陷安装相应补丁。</p>

<h2 id="toc_1">二、oracle组管理</h2>

<p>查看 dba组下的成员是否有Oracle用户：<br/>
<code>cat /etc/group |grep dba</code><br/>
若Oracle用户不在dba组，则将其加入：<br/>
<code>usermod -G dba 用户名</code></p>

<span id="more"></span><!-- more -->

<h2 id="toc_2">三、账号管理</h2>

<h4 id="toc_3">规范数据库账号，删除多余自建账号</h4>

<p>是否存在默认的范例数据库账号scott等，可以考虑删除scott账号<br/>
删除多余自建账号<code>drop user user_name cascade;</code></p>

<h4 id="toc_4">Dba权限账号检查，锁定禁用无用账号</h4>

<p><code>select username,profile from dba_users where account_status=&#39;OPEN&#39;;</code><br/>
整改：<br/>
锁定用户：<code>alter user &lt;用户名&gt; lock;</code><br/>
删除用户：<code>drop user &lt;用户名&gt; cascade;</code></p>

<h4 id="toc_5">禁止sysdba用户远程登录</h4>

<p>sysdba用户远程登录限制（查看Oracle登录认证方式）<br/>
检查：<br/>
<code>show parameter remote_login_passwordfile</code><br/>
整改：<br/>
<code>alter system set remote_login_passwordfile = NONE scope=spfile;</code><br/>
注：需要重启库生效。</p>

<h2 id="toc_6">四、密码管理</h2>

<h4 id="toc_7">登录失败的帐号锁定策略</h4>

<p><code>select * from dba_profiles order by 1;</code><br/>
关注FAILED_LOGIN_ATTEMPTS的设定值</p>

<h4 id="toc_8">数据库密码安全性校验函数</h4>

<p><code>select limit from dba_profiles where profile=&#39;DEFAULT&#39; and resource_name=&#39;PASSWORD_VERIFY_FUNCTION&#39;;</code></p>

<h2 id="toc_9">五、权限管理</h2>

<h4 id="toc_10">确保对$ORACLE_HOME/bin目录的访问权限尽可能少</h4>

<p>运行命令：<br/>
<code>chown -R oracle:dba $ORACLE_HOME/bin</code> （此命令在root用户下操作）<br/>
验证：<code>ls -l $ORACLE_HOME/bin</code> 确保该目录下的文件属主为oracle用户，且其他用户没有写权限。</p>

<h4 id="toc_11">应该只提供最小权限给用户（包括SYSTEM和OBJECT权限）</h4>

<p>在sqlplus中查看所有账户及其状态：<code>select username,account_status from dba_users;</code><br/>
修改默认账户的口令：<br/>
<code>ALTER USER user_name IDENTIFIED BY password;</code><br/>
锁定不需要的用户，使用SQL语句：<code>ALTER USER user PASSWORD EXPIRE;</code><br/>
注意锁定MGMT_VIEW、DBSNMP、SYSMAN帐号或修改密码。(如果要使用DBConsole ，MGMT_VIEW,DBSNMP 、SYSMAN不能锁定，请修改密码)<br/>
DIP、EXFSYS、OUTLN、TSMSYS、WMSYS默认已锁定，请验证。</p>

<h2 id="toc_12">六、监听管理</h2>

<h4 id="toc_13">修改默认监听端口</h4>

<p>修改（需重启监听）</p>

<pre class="line-numbers"><code class="language-text">$ORACLE_HOME/network/admin/listener.ora:
(ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))
修改PORT的值为新的监听端口-&gt;
(ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 3521))
</code></pre>

<p>确认：<br/>
<code>lsnrctl status</code></p>

<h4 id="toc_14">监听listener作ip访问限制</h4>

<p>修改（需重启监听）</p>

<pre class="line-numbers"><code class="language-$oracle_home/network/admin/sqlnet.ora">tcp.validnode_checking=yes
tcp.invited_nodes=(localhost, 本机ip, 应用服务器ip，管理机ip等)
</code></pre>

<p>重启监听：<code>lsnrctl stop；lsnrctl start</code></p>

<h4 id="toc_15">监听程序管理</h4>

<p>通过设置listener.ora文件中的参数<code>ADMIN_RESTRICTIONS_listener_name</code>来防止远程对监听程序的非授授权管理，在<code>$ORACLE_HOME/network/admin/listener.ora</code>文件中，设置<code>ADMIN_RESTRICTIONS_(listener_name)=ON</code></p>

<h4 id="toc_16">设置空闲连接时间</h4>

<pre class="line-numbers"><code class="language-text">$ vi $ORACLE_HOME/network/admin/sqlnet.ora
SQLNET.EXPIRE_TIME = 60
</code></pre>

<p>说明：客户端连接后在设置的时间内没有任何操作，客户端会自动断开。</p>

<h2 id="toc_17">七、审计管理</h2>

<p>ORACLE数据库具有对其内部所有发生的活动的审计能力，审计日志一般放在sys.aud$表中，也可以写入操作系统的审计跟踪文件中。可审计的活动有三种类型：登录尝试、数据库活动和对象存取，缺省情况下，数据库不启动审计，要求管理员配置数据库后才能启动审计。<br/>
使用文本方式，打开数据库配置文件<code>init&lt;sid&gt;.ora</code>,更改以下参数配置<code>AUDIT_TRAIL＝True</code>。<br/>
<code>init&lt;sid&gt;.ora</code>所在路径：</p>

<pre class="line-numbers"><code class="language-text">$ORACLE_HOME/database/            (windows)
$ORACLE_HOME/dbs/               (Linux)
</code></pre>

<p>接下来在sqlplus中执行以下两条命令：</p>

<pre class="line-numbers"><code class="language-text">alter system set audit_trail=&#39;OS&#39; scope=spfile;
alter system set Audit_sys_operations=true scope=spfile;
</code></pre>

<p>默认为false，当设置为true时，所有sys用户（包括以sysdba,sysoper身份登录的用户）的操作都会被记录。</p>

<h2 id="toc_18">八、日志管理</h2>

<p>日志目录管理、建议开启数据库的归档日志、保障数据安全</p>

<pre class="line-numbers"><code class="language-text">SQL&gt; show parameter dump
NAME                   TYPE        VALUE
---------------------- ----------- ------------------------------
background_core_dump   string      partial
background_dump_dest   string      /opt/oracle/admin/portaldb/bdump
core_dump_dest         string      /opt/oracle/admin/portaldb/cdump
max_dump_file_size     string      UNLIMITED
shadow_core_dump       string      partial
user_dump_dest         string      /opt/oracle/admin/portaldb/udump
SQL&gt; show parameter audit
NAME                   TYPE        VALUE
---------------------- ----------- ------------------------------
audit_file_dest        string      /opt/oracle/admin/portaldb/adump
</code></pre>

<h2 id="toc_19">九、数据字典保护</h2>

<p>只有sysdba才能访问数据字典基础表，普通用户不能查看X$开头的表。</p>

<pre class="line-numbers"><code class="language-text">SQL&gt; show parameter O7_DICTIONARY_ACCESSIBILITY
NAME TYPE VALUE
------------------------------------ ----------- ------------------------------
O7_DICTIONARY_ACCESSIBILITY booleanFALSE
SQL&gt; alter system set O7_DICTIONARY_ACCESSIBILITY= TRUE scope = spfile;
SQL&gt; shutdown immediate;
SQL&gt; startup;
</code></pre>

<h2 id="toc_20">十、资源限制管理</h2>

<p>Profile 分两部分(资源参数和密码参数)，<code>resource_limit</code>为 <code>TRUE</code> 限定资源参数<code>resource parameters</code>设置有效；不管 <code>resource_limit</code> 的值为 <code>TRUE</code> 或 FALSE密码参数<code>password parameters</code>设置始终有效。<br/>
<code>alter system set resource_limit=true scope=both;</code><br/>
常用资源参数（除非应用程序有明确的资源规划，一般不需修改）：<code>CPU_PER_SESSION、CPU_PER_CALL、LOGICAL_READS_PER_SESSION、LOGICAL_READS_PER_CALL、IDLE_TIME、CONNECT_TIME、PRIVATE_SGA</code></p>

<h2 id="toc_21">十一、漏洞管理</h2>

<h4 id="toc_22">SYS.DBMS_DEFER_SYS.DELETE_TRAN 存在 SQL 注入漏洞</h4>

<p><code>DELETE_TRAN</code> 对 <code>DESTINATION</code> 参数的处理存在问题，可能导致 SQL 注入攻击。攻击者利用该漏洞可以提升权限，还可以以系统管理员权限执行 SQL 命令。<br/>
查看哪些用户有执行权限：</p>

<pre class="line-numbers"><code class="language-text">col pp format a35
SELECT s.privilege||&#39; ON &#39;||s.owner||&#39;.&#39;||NVL(l.longname, s.table_name) pp, s.grantable, s.grantee FROM
sys.dba_tab_privs s, javasnm l WHERE s.table_name = l.short(+)
and s.privilege = &#39;EXECUTE&#39; and s.table_name like &#39;DBMS_DEFER_SYS%&#39;;
</code></pre>

<p>回收权限：</p>

<pre class="line-numbers"><code class="language-text">REVOKE EXECUTE ON SYS. DBMS_DEFER_SYS FROM DBA;
REVOKE EXECUTE ON SYS. DBMS_DEFER_SYS FROM WMSYS;
</code></pre>

<h4 id="toc_23">DBMS_AQELM 缓冲区溢出漏洞</h4>

<p>由于没有对其传入参数进行缓冲区边界检查，当传入超长字符串时，就会引起缓冲区溢出。攻击者利用此漏洞可以在服务器上执行任意代码。默认情况下，属于 <code>AQ_ADMINISTRATOR_ROLE</code> 角色的用户才有 <code>DBMS_AQELM</code> 包的执行权限。</p>

<pre class="line-numbers"><code class="language-sql">SELECT s.privilege||&#39; ON &#39;||s.owner||&#39;.&#39;||NVL(l.longname, s.table_name) pp, s.grantable, s.grantee FROM
sys.dba_tab_privs s, javasnm l WHERE s.table_name = l.short(+)
and s.privilege = &#39;EXECUTE&#39; and s.table_name like &#39;DBMS_AQELM%&#39;;
</code></pre>

<p>回收权限：</p>

<pre class="line-numbers"><code class="language-text">REVOKE EXECUTE ON SYS. DBMS_AQELM FROM AQ_ADMINISTRATOR_ROLE;
REVOKE EXECUTE ON SYS. DBMS_AQELM FROM EXECUTE_CATALOG_ROLE;
REVOKE EXECUTE ON SYS. DBMS_AQELM FROM SYSTEM;
</code></pre>
]]>
    </content>
  </entry>
  
</feed>
